Sp=((n1-1)/(n1-1+n3-1))*S1+((n3-1)/(n1-1+n3-1))*S3
Sp1=solve(Sp)
y=x
yLDA=as.numeric(t(m1-m3)%*%Sp1%*%t(y)-as.numeric(1/2*t(m1-m3)%*%Sp1%*%(m1+m3)))-log(p3/p1)
#plot(yLDA,col=as.numeric(x.lda.pred$class))
#abline(h=0)
# Misclassification:
yLDAclass=(yLDA<0)
# LDA
y1=seq(from=min(x[,1])-0.2,to=max(x[,1]),by=0.005)
y2=seq(from=min(x[,2]),to=max(x[,2])+0.2,by=0.005)
y1a=rep(y1,length(y2))
y2a=sort(rep(y2,length(y1)))
#points(y1a,y2a,col=2,cex=0.2)
ya=cbind(y1a,y2a)
yaLDA=as.numeric(t(m1-m3)%*%Sp1%*%t(ya)-
as.numeric(1/2*t(m1-m3)%*%Sp1%*%(m1+m3)))-log(p3/p1)
#plot(log10(chorizon[,"Cr"]),log10(chorizon[,"K"]),pch=Region,cex=Region/3+0.3)
#points(y1a[yaLDA<0],y2a[yaLDA<0],col=3,cex=0.2)
#points(y1a[yaLDA>0],y2a[yaLDA>0],col=2,cex=0.2)
#points(log10(chorizon[,"Cr"]),log10(chorizon[,"K"]),pch=Region,cex=Region/3+0.3)
boundLDA=abs(yaLDA)<0.01
lines(lowess(y1a[boundLDA],y2a[boundLDA]),col=1,lwd=1.5,lty=1)
plotellipse(m1,S1,perc=c(0.9),lty=c(2,2))
plotellipse(m3,S3,perc=c(0.9),lty=c(4,4))
legend("bottomright",legend=c("Group 1 (Caledon. Sed.)","Group 2 (other)",
"Covariance Group 1", "Covariance Group 2",
"LDA separation line"),
pch=c(4,1,NA,NA,NA),lty=c(NA,NA,4,2,1),lwd=c(NA,NA,1,1,1.5),
pt.cex=c(0.9,0.2,NA,NA,NA),cex=0.8)
lu <- read.csv("C:/Users/Jakob/Dropbox/Stud/5. Sem (WS2014)/Multivariate Statistik/09/flu.csv")
flu2 <- flu[-c(1:160),]
flu3 <- flu2[,-26]
daten <- log(flu3[,-1])
library(StatDA)
pfa1 <- pfa(scale(daten),factors=4,scores="regression")
#ab 4 keine großen veränderungen mehr
biplot(pfa1$loadings, pfa1$scores)
install.packages("GPArotation")
library("GPArotation")
pfa2 <- pfa(scale(daten),factors=4,scores="regression", rotation="varimax")
biplot(pfa2$loadings, pfa2$scores)
pfa3 <- pfa(scale(daten),factors=4,scores="regression", rotation="oblimin")
biplot(pfa3$loadings, pfa3$scores)
#MCD
library(robustbase)
pfa4 <- pfa(scale(daten), covmat=covMcd(daten),factors=4,scores="regression", rotation="varimax")
biplot(pfa4$loadings, pfa4$scores)
pfa5 <- pfa(scale(daten),covmat=covMcd(daten),factors=4,scores="regression", rotation="oblimin")
biplot(pfa5$loadings, pfa5$scores)
cluster <- kmeans(pfa5$scores,2)
plot(pfa5$scores, col=cluser$cluster +1)
group <- levels(factor(cluster$cluster))
subset(pfa5$scores[,1], cluster$cluster =1)
zeitreihe <- ts(pfa5$scores)
plot(zeitreihe)
flu <- read.csv("C:/Users/Jakob/Dropbox/Stud/5. Sem (WS2014)/Multivariate Statistik/09/flu.csv")
flu2 <- flu[-c(1:160),]
flu3 <- flu2[,-26]
daten <- log(flu3[,-1])
library(StatDA)
pfa1 <- pfa(scale(daten),factors=4,scores="regression")
#ab 4 keine großen veränderungen mehr
biplot(pfa1$loadings, pfa1$scores)
install.packages("GPArotation")
library("GPArotation")
pfa2 <- pfa(scale(daten),factors=4,scores="regression", rotation="varimax")
biplot(pfa2$loadings, pfa2$scores)
pfa3 <- pfa(scale(daten),factors=4,scores="regression", rotation="oblimin")
biplot(pfa3$loadings, pfa3$scores)
#MCD
library(robustbase)
pfa4 <- pfa(scale(daten), covmat=covMcd(daten),factors=4,scores="regression", rotation="varimax")
biplot(pfa4$loadings, pfa4$scores)
pfa5 <- pfa(scale(daten),covmat=covMcd(daten),factors=4,scores="regression", rotation="oblimin")
biplot(pfa5$loadings, pfa5$scores)
cluster <- kmeans(pfa5$scores,2)
plot(pfa5$scores, col=cluser$cluster +1)
group <- levels(factor(cluster$cluster))
subset(pfa5$scores[,1], cluster$cluster =1)
zeitreihe <- ts(pfa5$scores)
plot(zeitreihe)
install.packages("GPArotation")
flu <- read.csv("C:/Users/Jakob/Dropbox/Stud/5. Sem (WS2014)/Multivariate Statistik/09/flu.csv")
flu2 <- flu[-c(1:160),]
flu3 <- flu2[,-26]
daten <- log(flu3[,-1])
library(StatDA)
pfa1 <- pfa(scale(daten),factors=4,scores="regression")
#ab 4 keine großen veränderungen mehr
biplot(pfa1$loadings, pfa1$scores)
install.packages("GPArotation")
library("GPArotation")
pfa2 <- pfa(scale(daten),factors=4,scores="regression", rotation="varimax")
biplot(pfa2$loadings, pfa2$scores)
pfa3 <- pfa(scale(daten),factors=4,scores="regression", rotation="oblimin")
biplot(pfa3$loadings, pfa3$scores)
#MCD
library(robustbase)
pfa4 <- pfa(scale(daten), covmat=covMcd(daten),factors=4,scores="regression", rotation="varimax")
biplot(pfa4$loadings, pfa4$scores)
pfa5 <- pfa(scale(daten),covmat=covMcd(daten),factors=4,scores="regression", rotation="oblimin")
install.packages("GPArotation")
cluster <- kmeans(pfa5$scores,2)
plot(pfa5$scores, col=cluser$cluster +1)
group <- levels(factor(cluster$cluster))
subset(pfa5$scores[,1], cluster$cluster =1)
zeitreihe <- ts(pfa5$scores)
plot(zeitreihe)
install.packages("rrcov")
library(rrcov)
data(hemophilia)
lda <- LdaClassic(gr~., data=hemophilia)
lda_predict <- as.vector(predict(lda)@classification)
table(lda_predict, hemophilia$gr)
rlda <- Linda(gr~., data=hemophilia)
rlda_predict <- as.vector(predict(rlda)@classification)
table(rlda_predict, hemophilia$gr)
# quadratic classic method works best according to the misclassification rate seen in table(...)
qda <- QdaClassic(gr~., data=hemophilia)
qda_predict <- as.vector(predict(qda)@classification)
table(qda_predict, hemophilia$gr)
rqda <- QdaCov(gr~., data=hemophilia)
rqda_predict <- as.vector(predict(rqda)@classification)
table(rqda_predict, hemophilia$gr)
#--- 1b ---#
nums <- c(1:dim(hemophilia))
indices <- sample(nums, dim(hemophilia)[1]/2)
training_set <- hemophilia[indices,]
test_set <- hemophilia[-indices,]
lda2 <- LdaClassic(gr~., data=training_set)
lda_predict2 <- as.vector(predict(lda2, newData=test_set)@classification)
table(lda_predict2, hemophilia$gr)
nstall.packages("classifly")
library("classifly")
oliveData <- olives[1:9]
oliveData <- oliveData[-2]
lda3 <- LdaClassic(Region~., data=oliveData)
lda_predict3 <- as.vector(predict(lda3)@classification)
table(lda_predict3, oliveData$Region)
install.packages("classifly")
library("classifly")
oliveData <- olives[1:9]
oliveData <- oliveData[-2]
lda3 <- LdaClassic(Region~., data=oliveData)
lda_predict3 <- as.vector(predict(lda3)@classification)
table(lda_predict3, oliveData$Region)
install.packages("classifly")
library("classifly")
oliveData <- olives[1:9]
oliveData <- oliveData[-2]
lda3 <- LdaClassic(Region~., data=oliveData)
lda_predict3 <- as.vector(predict(lda3)@classification)
table(lda_predict3, oliveData$Region)
?qda
data(ohorizon)
library(StatDA)
data(ohorizon)
names(ohorizon)
shiny::runApp()
shiny::runApp()
shiny::runApp()
library(StatDA)
data(ohorizon)
X=ohorizon[,"XCOO"]
Y=ohorizon[,"YCOO"]
x1h=(X[Y<7600000 & Y>7500000]-753970)/1000
y1h=log10(ohorizon[Y<7600000 & Y>7500000,"Bi"])
plot(x1h,y1h,xlab="Distance from Monchegorsk [km]",ylab="Bi in O-horizon [mg/kg]",pch=4,cex=0.5,
yaxt="n",col=1,cex.lab=1.2)
axis(2,at=log10(a<-sort(c((10^(-50:50))%*%t(c(2,5,10))))),labels=a)
lines(smooth.spline(x1h,y1h,spar=0.7),col=1,lwd=1.4,lty=1)
attach(milk)
plot(X5,X4)
lm_X4 =lm(X4 ~ X5, data = milk)
abline(lm_X4, col = 2)
res <- lm_X4 - X4
lm_X4$residuals
plot(lm_X4$residuals)
data(Animals, package ="MASS")
brain <- Animals[c(1:24, 26:25, 27:28),]
mcd <- covMcd(log(brain))
plot(mcd, which = "distance", classic = TRUE)# 2 plots
plot(mcd, which = "dd")
ggplot(lm_X4$residuals)
plot(lm_X4$residuals)
names(lm_X4$residuals)
lm_X4$residuals[1]
ggplot((as.data.frame(lm_X4$residuals))) + geom_point()
typeof(lm_X4$residuals)
typeof(lm_X4$residuals[1])
typeof(lm_X4)
autoplot(lm_X4)
qplot(lm_X4$residuals)
qplot(lm_X4)
qplot(lm_X4$residuals)
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
load(moss,file = C:/Users/Jakob/Dropbox/Stud/5. Sem (WS2014)/Multivariate Statistik/08/pfa_cut_moss.RData)
load(moss,file = 'C:/Users/Jakob/Dropbox/Stud/5. Sem (WS2014)/Multivariate Statistik/08/pfa_cut_moss.RData')
load(file = 'C:/Users/Jakob/Dropbox/Stud/5. Sem (WS2014)/Multivariate Statistik/08/pfa_cut_moss.RData')
t <- log10(cut_moss)
shiny::runApp()
shiny::runApp()
shiny::runApp()
z <- pfa(t,2)
z <- pfa(cut_moss,2)
View(t)
shiny::runApp()
shiny::runApp()
z <- pfa(cut_moss,2)
shiny::runApp()
shiny::runApp()
x.mcd=covMcd(t,cor=TRUE)
x.rsc=scale(t,x.mcd$cent,sqrt(diag(x.mcd$cov)))
tmp=pfa(x.rsc,factors=3,covmat=x.mcd)
autoplot(tmp, data = t,loadings = TRUE, loadings.colour = 'blue',loadings.label = TRUE, loadings.label.size = 3)
typeof(t)
typeof(tmp)
tmp
ggplot() + geom_point(data =(t$scores), aes(x=t$scores[,1],y=t$scores[,2] ))
tmp$factors
tmp$loadings
t$Ni
ggplot() + geom_point(data =(t), aes(x=Ni,y=Ci ))
ggplot() + geom_point(data =(t), aes(x='Ni',y='Ci' ))
library(ggfortify)
df <- iris[c(1, 2, 3, 4)]
autoplot(prcomp(df))
state.x77
d.factanal <- factanal(state.x77, factors = 3, scores = 'regression')
autoplot(d.factanal, data = state.x77, colour = 'Income')
autoplot(d.factanal, label = TRUE, label.size = 3,
loadings = TRUE, loadings.label = TRUE, loadings.label.size  = 3)
autoplot(tmp, data = t,loadings = TRUE, loadings.colour = 'blue',loadings.label = TRUE, loadings.label.size = 3)
d.factanal <- factanal(scale(t), factors = 3, scores = 'regression')
autoplot(d.factanal, label = TRUE, label.size = 3,
loadings = TRUE, loadings.label = TRUE, loadings.label.size  = 3)
shiny::runApp()
x.mcd=covMcd(cut_moss,cor=TRUE)
x.rsc=scale(cut_moss,x.mcd$cent,sqrt(diag(x.mcd$cov)))
tmp=pfa(x.rsc,factors=3,covmat=x.mcd,scores='regression',rotation='varimax')
autoplot(tmp, label = TRUE, label.size = 3,
loadings = TRUE, loadings.label = TRUE, loadings.label.size  = 3)
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
x.mcd=covMcd(cut_moss,cor=TRUE)
x.rsc=scale(cut_moss,x.mcd$cent,sqrt(diag(x.mcd$cov)))
tmp=pfa(x.rsc,factors=3,covmat=x.mcd,scores='regression',rotation='varimax')
load(file = 'C:/Users/Jakob/Dropbox/Stud/5. Sem (WS2014)/Multivariate Statistik/08/pfa_cut_moss.RData')
x.mcd=covMcd(cut_moss,cor=TRUE)
x.rsc=scale(cut_moss,x.mcd$cent,sqrt(diag(x.mcd$cov)))
tmp=pfa(x.rsc,factors=3,covmat=x.mcd,scores='regression',rotation='varimax')
autoplot(tmp, label = TRUE, label.size = 3,
loadings = TRUE, loadings.label = TRUE, loadings.label.size  = 3,cex=0.8)
autoplot(tmp, label = TRUE, label.size = 3,
loadings = TRUE, loadings.label = TRUE, loadings.label.size  = 3,cex=5.8)
autoplot(tmp, label = TRUE, label.size = 3,
loadings = TRUE, loadings.label = TRUE, loadings.label.size  = 3,cex=0.08)
autoplot(tmp, label = TRUE, label.size = 3,
loadings = TRUE, loadings.label = TRUE, loadings.label.size  = 3,cex=0.00008)
autoplot(tmp, label = TRUE, label.size = 3,
loadings = TRUE, loadings.label = TRUE, loadings.label.size  = 3,cex=1)
x.rsc$
x.rsc
tmp$loadings
shiny::runApp()
lm.model<-lm(mpg~cyl+disp+hp+drat+wt, data=mtcars)
ggplot(lm.model, aes(.fitted, .resid))+geom_point() + stat_smooth(method="loess")+geom_hline(yintercept=0, col="red", linetype="dashed") +xlab("Fitted values")+ylab("Residuals")+ggtitle("Residual vs Fitted Plot")+theme_bw()
shiny::runApp()
ggplot(lm.model, aes(qqnorm(.stdresid)[[1]], .stdresid))+geom_point(na.rm = TRUE)+geom_abline(aes(qqline(.stdresid)))+xlab("Theoretical Quantiles")+ylab("Standardized Residuals")+ggtitle("Normal Q-Q")+theme_bw()
shiny::runApp()
lm.model2<-ltsReg(mpg~cyl+disp+hp+drat+wt, data=mtcars)
lm.model.fitted
lm.model$fitted.values
lm.model2$fitted.values
ggplot(lm.model2, aes(.fitted, .resid))+geom_point()
data(hbk)
lts <- ltsReg(Y ~ ., data = hbk)
lts
plot(lts, which = "rqq")
lm.model2
rid <- lm.model2$residuals/lm.model2$scale
plot(lm.model2$fitted,rid,cex.lab=1.2,xlab="Fitted values",ylab="Standardised LTS residuals",type="n")
points(lm.model2$fitted[lm.model2$lts.wt==0],rid[lm.model2$lts.wt==0],cex=0.8,pch=3)
points(lm.model2$fitted[lm.model2$lts.wt==1],rid[lm.model2$lts.wt==1],cex=0.8,pch=1)
abline(h=0,col="grey",lty=2)
abline(h=c(-2.5,2.5),lty=3,cex=1.1)
shiny::runApp()
points(lm.model2$fitted[lm.model2$lts.wt==0],rid[lm.model2$lts.wt==0],cex=0.8,pch=3)
lm.model3<-lmrob(mpg~cyl+disp+hp+drat+wt, data=mtcars)
plot(lm.model3, which = "rqq")
plot(lm.model3, which = 1)
plot(lm.model3, which = 2)
plot(lm.model3, which = 3)
plot(lm.model3, which = 4)
plot(lm.model2, which = 4)
plot(lm.model2, which = 1)
plot(lm.model3, which = 1)
plot(lm.model3, which = 2)
plot(lm.model3, which = 3)
ggplot(lm.model, aes(qqnorm(.stdresid)[[1]], .stdresid))+geom_point(na.rm = TRUE)+geom_abline(aes(qqline(.stdresid)))+xlab("Theoretical Quantiles")+ylab("Standardized Residuals")+ggtitle("Normal Q-Q")+theme_bw()
plot(lm.model3, which = 3)
plot(lm.model3, which = 2)
ggplot(lm.model, aes(qqnorm(.stdresid)[[1]], .stdresid))+geom_point(na.rm = TRUE)+geom_abline(aes(qqline(.stdresid)))+xlab("Theoretical Quantiles")+ylab("Standardized Residuals")+ggtitle("Normal Q-Q")+theme_bw()
plot(lm.model3, which = 2)
ggplot(lm.model, aes(.fitted, .resid))+geom_point() + stat_smooth(method="loess")+geom_hline(yintercept=0, col="red", linetype="dashed") +xlab("Fitted values")+ylab("Residuals")+ggtitle("Residual vs Fitted Plot")+theme_bw()
plot(lm.model3, which = 1)
plot(lm.model3, which = 3)
shiny::runApp()
library(mvoutlier); library(robCompositions); library(ggmap); library(sp)
data(meuse)
## data or not in lat/lon representation, so project to it:
coordinates(meuse) <- c("x", "y")
proj4string(meuse) <- CRS("+init=epsg:28992")
meuse <- spTransform(meuse, CRS("+proj=longlat +datum=WGS84"))
meuse <- data.frame(slot(meuse, "coords"), slot(meuse, "data"))
names(meuse)[1:2] <- c("lon", "lat")
## now the clustering (paritionierend)
meuse$cluster <-  as.factor(kmeans(scale(isomLR(meuse[,3:6])), 4)$cluster)
gmap <- get_googlemap(center=c(median(meuse$lon), median(meuse$lat)), zoom=14)
ggmap(gmap) + geom_point(aes(x=lon, y=lat, colour=cluster,
shape=cluster), data = meuse)
murder <- subset(crime, offense == "murder")
qmplot(lon, lat, data = murder, colour = I(’red’), size = I(3), darken = .3)
install.packages(qmplot)
install_github(qmplot)
install_github('qmplot')
install.packages('qmplot')
df <- round(data.frame(
x = jitter(rep(-95.36, 50), amount = .3),
y = jitter(rep( 29.76, 50), amount = .3)
), digits = 2)
map <- get_googlemap(’houston’, markers = df, path = df, scale = 2)
ggmap(map, extent = ’device’)
> library(ggmap)
> library(mapproj)
> map <- get_map(location = 'Europe', zoom = 4)
> ggmap(map)
library(ggmap)
library(mapproj)
map <- get_map(location = 'Europe', zoom = 4)
ggmap(map)
shiny::runApp()
shiny::runApp()
hc <- hclust(cut_moss)
hc <- hclust(dist(USArrests), "ave")
clustdata <- cutree(hc,3)
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
library(ggbiplot)
data(wine)
wine.pca <- prcomp(wine, scale. = TRUE)
ggbiplot(wine.pca, obs.scale = 1, var.scale = 1,
groups = wine.class, ellipse = TRUE, circle = TRUE) +
scale_color_discrete(name = '') +
theme(legend.direction = 'horizontal', legend.position = 'top')
wine.pca$x
pr <- prcomp(wine, scale. = TRUE)
data(wine)
wine.pca <- prcomp(wine, scale. = TRUE)
ggbiplot(pr, obs.scale = 1, var.scale = 1,
groups = pr, ellipse = TRUE, circle = TRUE)
ggbiplot(wine.pca, obs.scale = 1, var.scale = 1,
groups = wine.class, ellipse = TRUE, circle = TRUE) +
scale_color_discrete(name = '') +
theme(legend.direction = 'horizontal', legend.position = 'top')
ggbiplot(wine.pca, obs.scale = 1, var.scale = 1,
+          groups = wine.class, ellipse = TRUE, circle = TRUE) +
+     scale_color_discrete(name = '')
ggbiplot(wine.pca, obs.scale = 1, var.scale = 1,
+          groups = wine.class, ellipse = TRUE, circle = TRUE)   scale_color_discrete(name = '')
ggbiplot(wine.pca, obs.scale = 1, var.scale = 1,
groups = wine.class, ellipse = TRUE, circle = TRUE) +
scale_color_discrete(name = '')
ggbiplot(wine.pca,  groups = wine.class, ellipse = TRUE, circle = TRUE) +  scale_color_discrete(name = '')
ggbiplot(wine.pca, obs.scale = 1, var.scale = 1,
groups = wine.class, ellipse = TRUE, circle = TRUE) +
scale_color_discrete(name = '')
ggbiplot(wine.pca,  groups = wine.class, ellipse = TRUE, circle = TRUE) +  scale_color_discrete(name = '')
ggbiplot(wine.pca, obs.scale = 1, var.scale = 1,
groups = wine.class, ellipse = TRUE, circle = TRUE) +
scale_color_discrete(name = '')
ggbiplot(wine.pca,  groups = wine.class, ellipse = TRUE, circle = TRUE) +  scale_color_discrete(name = '')
ggbiplot(wine.pca) +  scale_color_discrete(name = '')
ggbiplot(wine.pca)
ggbiplot(wine.pca) +  scale_color_discrete(name = '')
ggbiplot(wine.pca, choices 2:3)
ggbiplot(wine.pca, choices =2:3)
wine
wine2 <- wine
wine2.pca
prc <- prcomp(wine, scale. = TRUE)
ggbiplot(prc, obs.scale = 1, var.scale = 1)
pc <- pcaCoDa(wine)
ggbiplot(pc, obs.scale = 1, var.scale = 1)
pc2 <- prc$x
pc2['rotation'] <- prc$rotation
getClass(prc)
pc <- getClass(prc)
pc2$rotation <- prc$rotation
prc$rotation
typeof(prc$rotation)
typeof(prc)
newlist <- list(pr, list(pc))
test1 <- list( c(a='a',b='b',c='c'), c(a='d',b='e',c='f'))
test2 <- as.data.frame(test1)
pc['scores']
pc$scores
pc2<-''
test1[,1]
test1[1,]
test1[]
test1[[1]]
pc2['a'] <- test1[[1]]
prc <- prcomp(wine, scale. = TRUE)
ggbiplot(pc$princompOutputClr, obs.scale = 1, var.scale = 1)
prc <- prcomp(wine, scale. = TRUE)
ggbiplot(pc, obs.scale = 1, var.scale = 1)
prc <- prcomp(wine, scale. = TRUE)
ggbiplot(pc$princompOutputClr, obs.scale = 1, var.scale = 1)
shiny::runApp()
ggbiplot(wine.pca)
ggbiplot(wine.pca)
prc <- prcomp(wine, scale. = TRUE)
ggbiplot(pc$princompOutputClr, obs.scale = 1, var.scale = 1)
screeplot(prc)
screeplot(prc, type = l)
screeplot(prc, type = 'l')
screeplot(pc$princompOutputClr, type = 'l')
ggbiplot(prc, labels =  rownames(prc))
ggbiplot(prc)
pf <- pfa(scale(wine),factors=3,scores="regression",rotation="varimax")
plot(pf)
biplot(pf)
autoplot(pf, data = wine)
ggbiplot(pf)
ggbiplot(pf, data=wine)
ggbiplot(pf, data=wine)+ scale_y_log10()
ggbiplot(pc$princompOutputClr, obs.scale = 1, var.scale = 1)
ggbiplot(pc$princompOutputClr, obs.scale = 1, var.scale = 1) + scale_y_log10()
ggbiplot(pc$princompOutputClr, obs.scale = 1, var.scale = 1)
ggbiplot(pc$princompOutputClr, obs.scale = 1, var.scale = 1) + scale_y_log10()
ggbiplot(pc$princompOutputClr, obs.scale = 1, var.scale = 1, choices =2:3 )
ggplot((wine), aes(Mg,Flav)) + geom_point()
ggplot((temdata), aes( ', options$x ,',',options$y,')) + geom_point() + coord_fixed()
ggplot((wine), aes(Mg,Flav)) + geom_point() + coord_fixed()
ggplot((wine), aes(Mg,Flav)) + geom_point() + coord_fixed(ratio = 1)
p <- ggplot(mtcars, aes(mpg, wt)) + geom_point()
# With one variable
p + facet_grid(. ~ cyl)
p + facet_grid(cyl ~ .)
p + facet_grid(vs ~ am)
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
gemas = read.csv("C:/Users/Jakob/shiny/r-shiny_v1.1/CSV-Files/GEMAS_Ap_MASTERDATAFILEforMapping_05DL_ORI.csv")
View(gemas)
gemas_clr = cenLR(gemas)
install.packages("robCompositions")
load(robCompositions)
load('robCompositions')
library('robCompositions')
gemas_clr = cenLR(gemas)
names(gemas)
gemas[,-c(1:5)]
gemas_clr = cenLR(gemas[,-c(1:5)])
gemas_cut =gemas[,-c(1:5)]
View(gemas_cut)
View(gemas_cut[-c(1:9),])
gemas_clr = gemas_cut[-c(1:9),]
View(gemas_clr)
gemas_clr.clr
gemas_clr = cenLR(gemas_clr)
View(gemas_clr)
gemas_clr = cenLR(gemas_clr[,c(1,2)])
gemas_clr = cenLR(gemas_clr[,c(3)])
gemas_clr = cenLR(gemas_clr[,c(2,3)])
gemas_clr = cenLR(gemas_clr[,c(26:33)])
wine_clr = cenLR(wine)
wine_clr
data.as.frame(wine_clr)
as.data.frame(wine_clr)
wine_clr_frame = wine_clr.clr
wine_clr_frame = wine_clr$x.clr
View(wine_clr_frame)
View(wine)
log(wine)
shiny::runApp('shiny')
shiny::runApp('shiny')
shiny::runApp('shiny')
shiny::runApp('shiny')
shiny::runApp('shiny')
shiny::runApp('shiny')
shiny::runApp('shiny')
shiny::runApp('shiny')
shiny::runApp('shiny')
View(x.rsc)
View(temdata)
View(x.rsc)
