{
    "contents" : "tryCatch({library(shiny)}, error = function(cond){return(NULL)})\ntryCatch({library(mvoutlier)}, error = function(cond){return(NULL)})\ntryCatch({library(robCompositions)}, error = function(cond){return(NULL)})\ntryCatch({library(VIM)}, error = function(cond){return(NULL)})\ntryCatch({library(StatDA)}, error = function(cond){return(NULL)})\ntryCatch({library(robustbase)}, error = function(cond){return(NULL)})\ntryCatch({library(MASS)}, error = function(cond){return(NULL)})\ntryCatch({library(mclust)}, error = function(cond){return(NULL)})\n\n#TODO: tryCatch\ntryCatch({library(devtools)}, error = function(cond){return(NULL)})\ntryCatch({library(robCompositions)}, error = function(cond){return(NULL)})\ntryCatch({library(ggplot2)}, error = function(cond){return(NULL)})\ntryCatch({library(ggbiplot)}, error = function(cond){return(NULL)})\n\n\n\n\n# class gemasInfo\nsetClass(\"gemasInfo\", representation(header = 'character', comment = 'character', sample = 'character', id = 'vector', coords = 'character',\n        variable = 'character', extraction = 'character', method = 'character', UDL = 'vector', LDL = 'vector', unit = 'character'), contains = NULL)\n\n# creating the class compData and its methods\nsetClass(\"compData\", representation(compositions = \"list\", externals = \"list\", coords = \"list\", ids = \"list\", transformations = \"list\", subsets = \"list\",\n        variablesTypes = 'vector', availableGemasInfo = 'logical', gemasInfo = 'gemasInfo'), contains = \"data.frame\")\n\n# createing a enviroment for saving temporary data\nvariablesEnv <- new.env()\nassign(\"dataList\", list(), env = variablesEnv)\nassign(\"currentData\", data.frame(), env = variablesEnv)\nassign(\"currentVariableGroup\", list(), env = variablesEnv)\nassign(\"currentVariableGroupName\", character, env = variablesEnv)\nassign('currentSubset', list(), env = variablesEnv)\nassign('currentSubsetName', list(), env = variablesEnv)\nassign(\"tempData\", data.frame(), env = variablesEnv)\nassign(\"uploadPath\", NULL, env = variablesEnv)\nassign(\"name\", NULL, env = variablesEnv)\nassign(\"tempGemasInfo\", 'gemasInfo', env = variablesEnv)\nassign(\"availableGemasInfo\", 'logical', env = variablesEnv)\nassign(\"currentDataName\", NULL, env = variablesEnv)\n\nshinyServer(function(input, output, session) {\n\n###############################################################################################################################################\n################################################### VARIOUS FUNCTIONS #########################################################################\n###############################################################################################################################################\n\n    getNAs <- function(data){\n        nas <- c()\n        for(i in (1:length(names(data)))){\n            nas[i] <- sum(is.na(data[i]))\n        }\n\n        return(nas)\n    }\n\n    createJSObject <- function(){\n        temp <- variablesEnv$currentData\n        variablesEnv$currentVariableGroup <- list()\n\n        data <- list()\n        data[[\"names\"]] = names(variablesEnv$currentData)\n        Data <- as.data.frame(temp@.Data)\n        names(Data) <- names(variablesEnv$currentData)\n        data[[\"data\"]] = Data\n        data[[\"compositions\"]] = temp@compositions\n        data[[\"externals\"]] = temp@externals\n        data[[\"coords\"]] = temp@coords\n        data[[\"ids\"]] = temp@ids\n        data[[\"transformations\"]] = temp@transformations\n        data[[\"subsets\"]] = temp@subsets\n        data[[\"variablesTypes\"]] = temp@variablesTypes\n        data[[\"nas\"]] = getNAs(temp)\n        data[[\"ldl\"]] = getLDL(temp)\n        data[[\"udl\"]] = getUDL(temp)\n\n        gemasInfo <- temp@gemasInfo\n        test <- list()\n        if(length(gemasInfo@header) > 0){\n            test[[\"HEADER\"]] <- gemasInfo@header\n        }\n        if(length(gemasInfo@comment) > 0){\n            test[[\"COMMENT_DATASET\"]] <- gemasInfo@comment\n        }\n        if(length(gemasInfo@id) > 0){\n            test[[\"SAMPLE_IDENTIFIER\"]] <- gemasInfo@id\n        }\n        if(length(gemasInfo@coords) > 0){\n            test[[\"COORDINATES\"]] <- gemasInfo@coords\n        }\n        if(length(gemasInfo@variable) > 0){\n            test[[\"VARIABLE\"]] <- gemasInfo@variable\n        }\n        if(length(gemasInfo@extraction) > 0){\n            test[[\"EXTRACTION\"]] <- gemasInfo@extraction\n        }\n        if(length(gemasInfo@method) > 0){\n            test[[\"METHOD\"]] <- gemasInfo@method\n        }\n        if(length(gemasInfo@UDL) > 0){\n            test[[\"UDL\"]] <- gemasInfo@UDL\n        }\n        if(length(gemasInfo@LDL) > 0){\n            test[[\"LDL\"]] <- gemasInfo@LDL\n        }\n        if(length(gemasInfo@unit) > 0){\n            test[[\"UNIT\"]] <- gemasInfo@unit\n        }\n        data[[\"gemasInfo\"]] <- test\n        return(data)\n    }\n\n    getLDL <- function(data){\n        ldl <- c()\n        limit <- data@gemasInfo\n        limit <- limit@LDL\n        if(length(limit) > 0){\n            for(i in (1:length(names(data)))){\n                if(is.na(limit[i])){\n                    ldl[i] <- \"\"\n                }\n                else{\n                    ldl[i] <- sum(data[i] < as.numeric(limit[i]))\n                }\n            }\n        }\n\n        return(ldl)\n    }\n\n\n    getUDL <- function(data){\n        udl <- c()\n        limit <- data@gemasInfo\n        limit <- limit@UDL\n        if(length(limit) > 0){\n            for(i in (1:length(names(data)))){\n                if(is.na(limit[i])){\n                    udl[i]<- \"\"\n                }\n                else{\n                    udl[i] <- sum(data[i] > as.numeric(limit[i]))\n                }\n            }\n        }\n\n        return(udl)\n    }\n\n    sendPopUpMessage <- function(textMessage){\n        session$sendCustomMessage(type = 'popUpMessage', message = textMessage)\n    }\n\n    createDataSelector <- function(names){\n        session$sendCustomMessage(type = 'createDataSelector', message = names)\n    }\n\n    renderDataInformation <- function(data){\n        session$sendCustomMessage(type = 'renderDataInformation', message = data)\n    }\n\n    resetConnector <- function(connectorName){\n        session$sendCustomMessage(type = 'resetConnector', message = connectorName)\n    }\n\n    setDataAndGroup <- function(fileName, groupName, subsetName){\n            names = c();\n            names[[\"fileName\"]] = fileName\n            names[[\"groupName\"]] = groupName\n            names[[\"subsetName\"]] = subsetName\n            session$sendCustomMessage(type = 'setSelectorsValue', message = names)\n    }\n\n    addNewDataToDataList <- function(newName, newData){\n        eval(parse(text = paste0(\"variablesEnv$dataList$\", variablesEnv$currentDataName ,\"<- variablesEnv$currentData\")))\n        eval(parse(text = paste0(\"variablesEnv$dataList$\",newName ,\"<-\", as.data.frame(newData))))\n        createDataSelector(as.list(names(variablesEnv$dataList)))\n        variablesEnv$currentDataName <- newName\n        variablesEnv$currentData <- newData\n    }\n\n    getAllIdAndCoordIndexes <- function(){\n        indexes <- c()\n        data <- variablesEnv$currentData\n        ids <- data@ids\n        coords <- data@coords\n        if(length(ids) > 0){\n            names <- names(ids)\n            for(i in 1:length(names)){\n                eval(parse(text = paste0('indexes <- c(indexes,ids$',names[i], ')')))\n            }\n        }\n\n        if(length(coords) > 0){\n            names <- names(coords)\n            for(i in 1:length(names)){\n                eval(parse(text = paste0('indexes <- c(indexes,coords$',names[i], ')')))\n            }\n        }\n\n        indexes <- unique(indexes) + 1\n\n        return(indexes)\n    }\n\n    getVariables <- function(variablesType, variablesName){\n        data <- variablesEnv$currentData\n        if(variablesType == \"compositions\"){\n            compositions <- data@compositions\n            return(as.vector(eval(parse(text = paste0('compositions$', variablesName))) + 1))\n        }else if(variablesType == \"externals\"){\n            externals <- data@externals\n            return(as.vector(eval(parse(text = paste0('externals$', variablesName))) + 1))\n        }else if(variablesType == \"coords\"){\n            coords <- data@coords\n            return(as.vector(eval(parse(text = paste0('coords$', variablesName))) + 1))\n        }else if(variablesType == \"ids\"){\n             ids <- data@ids\n             return(as.vector(eval(parse(text = paste0('ids$', variablesName))) + 1))\n        }else if(variablesType == \"transformations\"){\n              return(as.data.frame(data@transformations[as.character(variablesName)]))\n        }\n    }\n\n    updateVariables <- function(variablesType, variablesName, variables){\n        data <- variablesEnv$currentData\n        if(variablesType == \"compositions\"){\n             compositions <- data@compositions\n             compositions[[variablesName]] <- variables\n             data@compositions <- compositions\n        }else if(variablesType == \"externals\"){\n             externals <- data@externals\n             externals[[variablesName]] <- variables\n             data@externals <- externals\n        }else if(variablesType == \"coords\"){\n             coords <- data@coords\n             coords[[variablesName]] <- variables\n             data@coords <- coords\n        }else if(variablesType == \"ids\"){\n              ids <- data@ids\n              ids[[variablesName]] <- variables\n              data@ids <- ids\n        }\n        return(data)\n    }\n\n    getVariableFromTransformation <- function(variableName){\n        data <- variablesEnv$currentData\n        data <- data@transformations\n        names <- names(data)\n        variable <- NULL\n        for(i in 1:length(names)){\n            tmpTrans <- eval(parse(text = paste0('data$', names[i])))\n            try <- tryCatch({variable <- tmpTrans[variableName]}, error = function(cond){return(NULL)})\n            if(!is.null(try)){\n                break;\n            }\n        }\n\n        return(variable)\n    }\n\n###############################################################################################################################################\n####################################################### DATA UPLOAD ###########################################################################\n###############################################################################################################################################\n\n    session$sendCustomMessage(type = 'allRPackages', message = sort(installed.packages()[,1]))\n    createDataSelector(as.list(names(variablesEnv$dataList)))\n\n  observe({\n      file <- input$uploadCSVFile\n      if(!is.null(file)){\n        variablesEnv$uploadPath <- file$datapath\n\n        session$sendCustomMessage(type = \"createCSVFileOptionDialog\", message = file$name)\n\n      }\n  })\n\n  observe({\n    file <- input$uploadRData\n    if(!is.null(file)){\n        variablesEnv$uploadPath <- file$datapath\n        variablesEnv$tempData <- load(file$datapath)\n        variablesEnv$tempData <- eval(parse(text = variablesEnv$tempData[1]))\n        if(!is.null(variablesEnv$tempData)){\n            variablesEnv$uploadPath <- NULL\n            variablesEnv$availableGemasInfo <- FALSE\n            session$sendCustomMessage(type = \"createFileOptionDialog\", message = file$name)\n        }\n    }\n  })\n\n  observe({\n    if(!is.null(input$preview)){\n        options <- input$preview\n        if(!is.null(variablesEnv$uploadPath)){\n\n            try <- tryCatch({variablesEnv$tempData <- read.table(variablesEnv$uploadPath, nrows = 15, header = options$header,\n                                                                sep = options$separator, dec = options$decimal,\n                                                                quote = options$quotes)},\n                            error = function(cond){return(NULL)})\n\n            if(is.null(try)){\n                sendPopUpMessage('ERROR: corrupted file!')\n                return(NULL)\n            }\n        }\n\n            session$sendCustomMessage(type = 'createPreviewTable', message = variablesEnv$tempData)\n        }\n  })\n\n  observe({\n    if(!is.null(input$uploadChosenFile)){\n        options <- input$uploadChosenFile\n        if(!is.null(variablesEnv$uploadPath)){\n            tmp <- readLines(variablesEnv$uploadPath, n = 30)\n            tmp <- tmp[substr(tmp, 1, 1) != '#']\n\n            if(csvWithInfo(tmp[1]) == FALSE){\n                variablesEnv$availableGemasInfo <- FALSE\n                variablesEnv$tempData <- read.table(variablesEnv$uploadPath, header = options$header,\n                        sep = options$separator, dec = options$decimal,\n                        quote = options$quotes)\n            }else{\n                variablesEnv$availableGemasInfo <- TRUE\n                import <- importGemasCSV(options)\n\n                if(is.null(import)){\n                    resetConnector('uploadCSVFile')\n                    return(NULL)\n                }\n            }\n        }\n        variablesEnv$name <- options$name\n        data <- list()\n        data[[\"data\"]] <- variablesEnv$tempData\n        data[[\"names\"]] <- names(variablesEnv$tempData)\n        session$sendCustomMessage(type = 'createChooseVariableDialog', message = data)\n     }\n  })\n\n  csvWithInfo <- function(firstEntry){\n    if(length(grep('HEADER', firstEntry)) != 0){\n        return(TRUE);\n    }\n    else if(length(grep('COMMENT DATASET', firstEntry)) != 0){\n         return(TRUE);\n    }\n    else if(length(grep('SAMPLE IDENTIFIER', firstEntry)) != 0){\n        return(TRUE);\n    }\n    else if(length(grep('COORDINATES', firstEntry)) != 0){\n        return(TRUE);\n    }\n    else if(length(grep('VARIABLE', firstEntry)) != 0){\n        return(TRUE);\n    }\n    else if(length(grep('UNIT', firstEntry)) != 0){\n        return(TRUE);\n    }\n    else if(length(grep('EXTRACTION', firstEntry)) != 0){\n        return(TRUE);\n    }\n    else if(length(grep('METHOD', firstEntry)) != 0){\n        return(TRUE);\n    }\n    else if(length(grep('UDL', firstEntry)) != 0)\n    {\n        return(TRUE);\n    }\n    else if(length(grep('LDL', firstEntry)) != 0){\n        return(TRUE);\n    }\n    else if(length(grep('COMMENT VARIABLES', firstEntry)) != 0){\n        return(TRUE);\n    }\n    else{\n        return(FALSE);\n    }\n  }\n\n  importGemasCSV <- function(options){\n\n    try <- tryCatch({tmp <- read.table(variablesEnv$uploadPath, header = T, sep = options$separator, dec = options$decimal, quote = options$quotes)},\n                          error = function(cond){return(NULL)})\n\n    if(is.null(try)){\n        sendPopUpMessage('ERROR: corrupted-file')\n        return(NULL);\n    }\n\n    skip <- (1:length(tmp[,1]))[tmp[,1]==\"\"][1]\n\n   try <- tryCatch({tmp <- read.table(variablesEnv$uploadPath, header = T, sep = options$sep, dec = options$decimal, quote = options$quotes, skip = skip)},\n                    error = function(cond){return(NULL)})\n\n\n    if(is.null(try)){\n        sendPopUpMessage('ERROR: corrupted-file')\n        return(NULL);\n    }\n\n\n    colNames <- names(tmp[\"VARIABLE\"==tmp[,1],])\n\n    try <- tryCatch({tmp <- read.table(variablesEnv$uploadPath, header = F,\n                      sep = options$separator, dec = options$decimal,\n                      quote = options$quotes)}, error=function(cond){return(NULL)})\n\n\n    if(is.null(try)){\n        sendPopUpMessage('ERROR: corrupted-file')\n        return(NULL);\n    }\n\n    tmp <- as.matrix(tmp)\n\n    gemasInfo <- new(\"gemasInfo\")\n  for ( i in 1:skip ) {\n    l <- tmp[i,]\n    print(l[1])\n    if( l[1]==\"HEADER\" ) {\n      gemasInfo@header <- paste(l[-1],sep=\"\",collapse=\"\")\n      print(gemasInfo@header)\n      }\n    if( l[1]==\"COMMENT DATASET\" ) {\n      gemasInfo@comment <- paste(l[-1],sep=\"\",collapse=\"\")\n      print(gemasInfo@comment)\n      }\n    if( l[1]==\"SAMPLE IDENTIFIER\" ) {\n      gemasInfo@id <- as.vector(l[-1])\n      print(gemasInfo@id)\n      }\n    if( l[1]==\"COORDINATES\" ) {\n      gemasInfo@coords <- as.vector(l[-1])\n      print(gemasInfo@coords)\n      }\n    if( l[1]==\"VARIABLE\" ) {\n      gemasInfo@variable <- colNames\n      print(gemasInfo@variable)\n      }\n    if( l[1]==\"UNIT\" ) {\n    print(class(l[-1]))\n      gemasInfo@unit <- as.vector(l[-1])\n      print(gemasInfo@unit)\n      }\n    if( l[1]==\"EXTRACTION\" ) {\n      gemasInfo@extraction <- as.vector(l[-1])\n      print(gemasInfo@extraction)\n      }\n    if( l[1]==\"METHOD\" ) {\n      gemasInfo@method <- as.vector(l[-1])\n      print(gemasInfo@method)\n      }\n    if( l[1]==\"UDL\" ) {\n      gemasInfo@UDL <- as.numeric(l[-1])\n      print(gemasInfo@UDL)\n      }\n    if( l[1]==\"LDL\" ) {\n      gemasInfo@LDL <- as.numeric(l[-1])\n      print(gemasInfo@LDL)\n      }\n    if( l[1]==\"COMMENT VARIABLES\" ) {\n      comment_var <- as.vector(l[-1])\n      print(comment_var)\n      }\n    }\n\n    if ( !is.na(gemasInfo@id[1]) ) gemasInfo@id <- colNames[gemasInfo@id != \"\"]\n    if ( length(gemasInfo@id) != 1 ) gemasInfo@id <- NA\n    xcoo <- colNames[ gemasInfo@coords == \"XCOO\" ]\n    if ( length(xcoo) != 1 ) xcoo <- NA\n    ycoo <- colNames[ gemasInfo@coords == \"YCOO\" ]\n    if ( length(ycoo) != 1 ) ycoo <- NA\n    gemasInfo@coords <- c(xcoo,ycoo)\n    str(gemasInfo)\n    variablesEnv$tempGemasInfo <- gemasInfo\n\n    try <- tryCatch({variablesEnv$tempData <- read.table(variablesEnv$uploadPath, header = T,\n                                        sep = options$separator, dec = options$decimal,\n                                        quote = options$quotes, skip = skip)}, error = function(cond){return(NULL)})\n\n    if(is.null(try)){\n        sendPopUpMessage('ERROR: corrupted file!')\n        resetConnector('uploadChosenFile')\n        return(NULL)\n    }\n\n    variablesEnv$tempData <- variablesEnv$tempData[,-1]\n\n  }\n\n observe({\n    if(!is.null(input$chosenVariables)){\n        chosenVariables <- input$chosenVariables\n        names <- (names(chosenVariables))\n        types <- unlist(chosenVariables$type)\n        variablesTypes <- unlist(chosenVariables$variablesTypes)\n\n        tmp <- variablesEnv$tempData\n        for(index in (1: length(variablesTypes))){\n            eval(parse(text = paste0('tmp[,index] <- as.', variablesTypes[index],'(tmp[,index])')))\n        }\n        data <- new(\"compData\", tmp, availableGemasInfo = variablesEnv$availableGemasInfo)\n        data@variablesTypes <- variablesTypes\n\n        for(index in 1:length(types)){\n            variables <- unlist(chosenVariables[index])\n            if(!is.null(variables)){\n                if(types[index] == \"comp\"){\n                    data@compositions[[names[index]]] <- variables\n                }\n                else if(types[index] == \"extern\"){\n                    data@externals[[names[index]]] <- variables\n                }\n                else if(types[index] == \"coord\"){\n                    data@coords[[names[index]]] <- variables\n                }\n                else{\n                    data@ids[[names[index]]] <- variables\n                }\n            }\n        }\n        if(variablesEnv$availableGemasInfo){\n            data@gemasInfo <- variablesEnv$tempGemasInfo\n        }\n\n        eval(parse(text = paste0(\"variablesEnv$dataList$\",variablesEnv$name ,\"<- data\")))\n        variablesEnv$uploadPath <- NULL\n\n        sendPopUpMessage('Chosen data was successfully uploaded!')\n        names <- as.list(names(variablesEnv$dataList))\n        createDataSelector(names)\n    }\n  })\n\n    # chosen data from the data selector\n    observe({\n        input$dataSelectorChosenData\n        if(!is.null(input$dataSelectorChosenData)){\n            if(input$dataSelectorChosenData != \"\"){\n                if(!is.null(variablesEnv$currentDataName)){\n                    eval(parse(text = paste0(\"variablesEnv$dataList$\",variablesEnv$currentDataName ,\"<-variablesEnv$currentData\")))\n                }\n\n                variablesEnv$currentDataName <- as.character(input$dataSelectorChosenData)\n                variablesEnv$currentData <- variablesEnv$dataList[as.character(input$dataSelectorChosenData)]\n                variablesEnv$currentData <- eval(parse(text = paste0(\"variablesEnv$currentData$\", as.character(input$dataSelectorChosenData))))\n                renderDataInformation(createJSObject())\n\n            }\n        }\n    })\n\n    # chosen package\n    observe({\n        input$chosenPackage\n        if(!is.null(input$chosenPackage)){\n            eval(parse(text = paste0(\"library(\", input$chosenPackage, \")\")))\n            eval(parse(text = paste0('availableDataInThePackage <- data(package = \"', input$chosenPackage, '\")$results[,3]')))\n            if(length(availableDataInThePackage) == 0){\n                sendPopUpMessage('Chosen package contains no data!')\n            }\n            else{\n                session$sendCustomMessage(type = 'availableDataInThePackage', message = availableDataInThePackage)\n                variablesEnv$availableGemasInfo <- FALSE\n            }\n        }\n    })\n\n    #chosen data from package\n    observe({\n        variablesEnv$name <- input$chosenData\n        if(!is.null(variablesEnv$name)){\n            eval(parse(text = paste0(\"data(\", variablesEnv$name, \")\")))\n            variablesEnv$tempData <- eval(parse(text = variablesEnv$name))\n            if(!is.null(variablesEnv$tempData)){\n                variablesEnv$uploadPath <- NULL\n                session$sendCustomMessage(type = 'createFileOptionDialog', message = variablesEnv$name)\n            }\n        }\n    })\n\n#######################################################################################################################################\n############################################################ EDIT DATA ################################################################\n#######################################################################################################################################\n########################################################## REMOVE #####################################################################\nobserve({\n    options <- input$removeColumn\n    if(!is.null(options)){\n        indexes <- unlist(options$indexes)\n        data <- variablesEnv$currentData\n        Data <- as.data.frame(data@.Data)\n        tmpNames <- names(data)\n        tmpNames <- tmpNames[- (indexes + 1)]\n        Data <- Data[-(indexes + 1)]\n        data@.Data <- Data\n        names(data) <- tmpNames\n        compositions <- data@compositions\n        tmpNames <- names(compositions)\n\n        if(length(tmpNames) > 0){\n            for(i in (1: length(tmpNames))){\n                comp <- eval(parse(text = paste0('compositions$', tmpNames[i])))\n                for(k in (1 : length(indexes))){\n                  indexesToDelete <- which(comp == indexes[k])\n                  if(length(indexesToDelete) > 0){\n                      comp <- comp[-indexesToDelete]\n                  }\n              }\n              \n              for(j in (1 :length(indexes))){\n                if(length(comp[comp >= indexes[j]]) > 0){\n                  comp[comp >= indexes[j]] <- comp[comp >= indexes[j]] - 1\n                }\n              }\n              if(length(comp) == 0){\n                comp <- c()\n              }\n              eval(parse(text = paste0('compositions$', tmpNames[i], ' <- comp')))\n            }\n            data@compositions <- compositions\n        }\n\n        externals <- data@externals\n        tmpNames <- names(externals)\n        if(length(tmpNames) > 0){\n          for(i in (1: length(tmpNames))){\n            ext <- eval(parse(text = paste0('externals$', tmpNames[i])))\n            for(k in (1 : length(indexes))){\n              indexesToDelete <- which(ext == indexes[k])\n              if(length(indexesToDelete) > 0){\n                ext <- ext[-indexesToDelete]\n              }\n            }\n            \n            for(j in (1 :length(indexes))){\n              if(length(ext[ext >= indexes[j]]) > 0){\n                ext[ext >= indexes[j]] <- ext[ext >= indexes[j]] - 1\n              }\n            }\n            if(length(ext) == 0){\n              ext <- c()\n            }\n            eval(parse(text = paste0('externals$', tmpNames[i], ' <- ext')))\n          }\n          data@externals <- externals\n        }\n\n        coords <- data@coords\n        tmpNames <- names(coords)\n        if(length(tmpNames) > 0){\n          for(i in (1: length(tmpNames))){\n            coord <- eval(parse(text = paste0('coords$', tmpNames[i])))\n            for(k in (1 : length(indexes))){\n              indexesToDelete <- which(coord == indexes[k])\n              if(length(indexesToDelete) > 0){\n                coord <- coord[-indexesToDelete]\n              }\n            }\n            \n            for(j in (1 :length(indexes))){\n              if(length(coord[coord >= indexes[j]]) > 0){\n                coord[coord >= indexes[j]] <- coord[coord >= indexes[j]] - 1\n              }\n            }\n            if(length(coord) == 0){\n              coord <- c()\n            }\n            eval(parse(text = paste0('coords$', tmpNames[i], ' <- coord')))\n          }\n          data@coords <- coords\n        }\n\n        ids <- data@ids\n        tmpNames <- names(ids)\n        if(length(tmpNames) > 0){\n          for(i in (1: length(tmpNames))){\n            id <- eval(parse(text = paste0('ids$', tmpNames[i])))\n            for(k in (1 : length(indexes))){\n              indexesToDelete <- which(id == indexes[k])\n              if(length(indexesToDelete) > 0){\n                id <- id[-indexesToDelete]\n              }\n            }\n            \n            for(j in (1 :length(indexes))){\n              if(length(id[id >= indexes[j]]) > 0){\n                id[id >= indexes[j]] <- id[id >= indexes[j]] - 1\n              }\n            }\n            if(length(id) == 0){\n              id <- c()\n            }\n            eval(parse(text = paste0('ids$', tmpNames[i], ' <- id')))\n          }\n          data@ids <- ids\n        }\n        \n        variablesEnv$currentData <- data\n        renderDataInformation(createJSObject())\n        sendPopUpMessage('Column(s) successfully removed!')\n        resetConnector('removeColumn')\n        setDataAndGroup(variablesEnv$currentDataName, options$group, options$subset)\n    }\n})\n\n############################################################ ADD ######################################################################\n    observe({\n        options <- input$addOrEditColumn\n        if(!is.null(options)){\n            data <- variablesEnv$currentData\n            Data <- as.data.frame(data@.Data)\n            names(Data) = names(data)\n            names <- unlist(options$names)\n            commands <- unlist(options$commands)\n            attach(data)\n\n\n            method = NULL\n            unit = NULL\n            extraction = NULL\n\n            gemasInfo <- data@gemasInfo\n            if(!is.null(gemasInfo) && length(gemasInfo) > 1){\n                method <- gemasInfo@method\n                index <- ceiling(0.6 * length(method))\n                method <- method[index]\n                unit <- gemasInfo@unit[index]\n\n            }\n\n            for(i in (1: length(commands))){\n                try <- tryCatch({eval(parse(text = commands[i]))}, error = function(cond){return(NULL)})\n                if(is.null(try)){\n                    sendPopUpMessage('Invalid command!');\n                    detach(data)\n                    return(NULL);\n                }else{\n                    eval(parse(text = paste0('Data[\"', names[i], '\"] <-', names[i])))\n                }\n            }\n\n            detach(data)\n            data@.Data <- Data\n            names(data) <- names(Data)\n            variablesEnv$currentData <- data\n\n            if(!is.null(options$typeOfVariables)){\n                if(options$typeOfVariables != 'allGroups'){\n                    variables <- getVariables(options$typeOfVariables, options$variables) - 1\n                    lengthData <- length(names(data)) - length(commands)\n                    newLength <- lengthData + (length(commands) -1)\n                    variables <- c(variables, (lengthData:newLength))\n\n                    variablesEnv$currentData <-  updateVariables(options$typeOfVariables, options$variables, variables)\n                }\n            }\n\n            renderDataInformation(createJSObject())\n            setDataAndGroup(variablesEnv$currentDataName, options$group, options$subset)\n            sendPopUpMessage(options$message)\n            resetConnector('addOrEditColumn')\n        }\n    })\n\n########################################################################################################################################\n################################################################### DATA MANIPULATION ##################################################\n########################################################################################################################################\n################################################################### IMPUTATION #########################################################\n############################################ impCoda ###################################################################################\n    observe({\n        options <- input$impCodaImp\n        if(!is.null(options)){\n            data <- as.data.frame(variablesEnv$currentData)\n            variablesEnv$currentVariableGroup <- (unlist(options$variablesGroup) + 1)\n            variablesEnv$currentSubset <- (unlist(options$subsetGroup) + 1)\n            if(length(variablesEnv$currentVariableGroup) != 0){\n                data <- data[variablesEnv$currentVariableGroup]\n            }\n\n            try <- tryCatch({eval(parse(text = paste0('tmp <- impCoda(x = data, ', 'maxit=', options$maxit, ', method=\"', options$method, '\")')))},\n                            error = function(cond){return(NULL)})\n            if(is.null(try)){\n                sendPopUpMessage(\"ERROR: too much NA's on one row!\")\n            }\n            else{\n                data <- variablesEnv$currentData\n                tmp <- tmp$xImp\n                data <- replaceOriginalDataWithImputation(data, tmp)\n\n                if(options$name != 0){\n                    options(options$name, data)\n                }else{\n                    variablesEnv$currentData <- data\n                }\n                renderDataInformation(createJSObject())\n                setDataAndGroup(variablesEnv$currentDataName, options$group, options$subset)\n                sendPopUpMessage('Imputation successfully done!')\n                resetConnector('impCoda')\n            }\n         }\n    })\n\n########################################### impKNNa ############################################\n    observe({\n        options <- input$impKNNaImp\n        if(!is.null(options)){\n            data <- as.data.frame(variablesEnv$currentData)\n            variablesEnv$currentVariableGroup <- (unlist(options$variablesGroup) +1)\n            if(length(variablesEnv$currentVariableGroup) != 0){\n                data <- data[variablesEnv$currentVariableGroup]\n            }\n\n            try <- tryCatch({eval(parse(text = paste0('tmp <- impKNNa(x = data, ', 'k=', options$k,')')))},\n                            error = function(cond){return(NULL)})\n            if(is.null(try)){\n                sendPopUpMessage(\"ERROR: too much NA's on one row!\")\n            }\n            else{\n                data <- variablesEnv$currentData\n                tmp <- tmp$xImp\n                data <- replaceOriginalDataWithImputation(data, tmp)\n\n                if(options$name != 0){\n                    addNewDataToDataList(options$name, data)\n                }else{\n                    variablesEnv$currentData <- data\n                }\n                renderDataInformation(createJSObject())\n                setDataAndGroup(variablesEnv$currentDataName, options$group, options$subset)\n                sendPopUpMessage('Imputation successfully done!')\n                resetConnector('impKNNa')\n            }\n         }\n    })\n\n########################################## kNN #################################################\n    observe({\n        options <- input$kNNImp\n        if(!is.null(options)){\n           data <- as.data.frame(variablesEnv$currentData)\n           variablesEnv$currentVariableGroup <- (unlist(options$variablesGroup) +1)\n            if(length(variablesEnv$currentVariableGroup) != 0){\n                data <- data[variablesEnv$currentVariableGroup]\n            }\n\n            try <- tryCatch({eval(parse(text = paste0('tmp <- kNN(data = data, ', 'k=', options$k, ')')))},\n                            error = function(cond){return(NULL)})\n\n            if(is.null(try)){\n                sendPopUpMessage(\"ERROR: too much NA's on one row!\")\n            }\n            else\n            {\n                tmp <- tmp[1:length(data)]\n\n                data <- variablesEnv$currentData\n                data <- replaceOriginalDataWithImputation(data, tmp)\n\n                if(options$name != 0){\n                    addNewDataToDataList(options$name, data)\n                }else{\n                    variablesEnv$currentData <- data\n                }\n\n                renderDataInformation(createJSObject())\n                setDataAndGroup(variablesEnv$currentDataName, options$group, options$subset)\n                sendPopUpMessage('Imputation successfully done!')\n                resetConnector('kNNImp')\n            }\n         }\n    })\n\n############################################ irmi ################################################\n    observe({\n        options <- input$irmiImp\n        if(!is.null(options)){\n            data <- as.data.frame(variablesEnv$currentData)\n            variablesEnv$currentVariableGroup <- (unlist(options$variablesGroup) +1)\n            if(length(variablesEnv$currentVariableGroup) != 0){\n                data <- data[variablesEnv$currentVariableGroup]\n            }\n\n            try <- tryCatch({eval(parse(text = paste0('tmp <- irmi(x = data)')))},\n                            error = function(cond){return(NULL)})\n\n            if(is.null(try)){\n                sendPopUpMessage(\"ERROR: too much NA's on one row!\")\n            }\n            else{\n                data <- variablesEnv$currentData\n                data <- replaceOriginalDataWithImputation(data, tmp)\n\n                if(options$name != 0){\n                    addNewDataToDataList(options$name, data)\n                }else{\n                    variablesEnv$currentData <- data\n                }\n                renderDataInformation(createJSObject())\n                setDataAndGroup(variablesEnv$currentDataName, options$group, options$subset)\n                sendPopUpMessage('Imputation successfully done!')\n                resetConnector('irmiImp')\n            }\n         }\n    })\n\n\n    replaceOriginalDataWithImputation <- function(data, imputation){\n        Data <- data@.Data\n        if(length(variablesEnv$currentVariableGroup) != 0){\n            Data[variablesEnv$currentVariableGroup] <- as.data.frame(imputation)\n            data@.Data <- Data\n        }\n        else{\n            Data <- tmp\n            data@.Data <- imputation\n        }\n        return(data)\n    }\n\n\n#######################################################################################################################################\n######################################################### DETECTION LIMIT #############################################################\n#######################################################################################################################################\n######################################################### impRZilr ####################################################################\n    observe({\n        options <- input$inpRZilr\n        if(!is.null(options)){\n            data <- as.data.frame(variablesEnv$currentData)\n            variablesEnv$currentVariableGroup <- (unlist(options$variablesGroup) + 1)\n            dl <- data@gemasInfo\n            dl <- dl@LDL\n            dl <- as.numeric(dl)\n            if(length(options$variablesGroup) != 0){\n                data <- data[variablesEnv$currentVariableGroup]\n                dl <- dl[variablesEnv$currentVariableGroup]\n            }\n\n            try <- tryCatch({eval(parse(text = paste0('tmp <- impRZilr(x = data, dl = dl, method = \"', options$method ,'\")')))},\n                            error = function(cond){return(NULL)})\n\n            if(is.null(try)){\n                sendPopUpMessage(\"ERROR occoured!\")\n            }else{\n                data <- variablesEnv$currentData\n                data <- replaceOriginalDataWithImputation(data, tmp$x)\n\n                if(options$name != 0){\n                    addNewDataToDataList(options$name, data)\n                }\n                else{\n                    variablesEnv$currentData <- data\n                }\n\n                renderDataInformation(createJSObject())\n                setDataAndGroup(variablesEnv$currentDataName, options$group, options$subset)\n                sendPopUpMessage('Imputation successfully done!')\n                resetConnector('impRZilr')\n            }\n        }\n    })\n\n########################################################## DL * factor #################################################################\n    observe({\n        options <- input$DLMultiplyByFactor\n        if(!is.null(options)){\n            data <- as.data.frame(variablesEnv$currentData)\n            variablesEnv$currentVariableGroup <- (unlist(options$variablesGroup) + 1)\n            constant <- options$constant\n            dl <- data@gemasInfo\n            dl <- dl@LDL\n            dl <- as.numeric(dl)\n            if(length(options$variablesGroup) != 0){\n                data <- data[variablesEnv$currentVariableGroup]\n                dl <- dl[variablesEnv$currentVariableGroup]\n            }\n            tmp <- c()\n            for(i in (1: length(dl))){\n                col <- data[i]\n                if(length(col[col < dl[i]]) > 0){\n                    col[col < dl[i]] <- eval(parse(text = paste(dl[i],'*',constant)))\n                }\n                tmp[i] <- col\n            }\n\n            data <- variablesEnv$currentData\n            data <- replaceOriginalDataWithImputation(data, tmp)\n\n            if(options$name != 0){\n                addNewDataToDataList(options$name, data)\n             }else{\n                variablesEnv$currentData <- data\n             }\n\n             renderDataInformation(createJSObject())\n             setDataAndGroup(variablesEnv$currentDataName, options$group, options$subset)\n             sendPopUpMessage('Imputation successfully done!')\n             resetConnector('DLMultiplyByFactor')\n        }\n    })\n\n#######################################################################################################################################\n######################################################### TRANSFORMATIONS #############################################################\n#######################################################################################################################################\n########################################################### addLR #####################################################################\n    observe({\n        options <- input$addLR\n        if(!is.null(options)){\n            data <- as.data.frame(variablesEnv$currentData)\n            variablesEnv$currentVariableGroup <- (as.numeric(unlist(options$variablesGroup)) + 1)\n            if(length(options$variablesGroup) != 0){\n                data <- data[variablesEnv$currentVariableGroup]\n            }\n\n            try <- tryCatch({eval(parse(text = paste0('tmp <- addLR(x = data, ivar = ', as.numeric(options$ivar), ')')))},\n                            error = function(cond){return(NULL)})\n\n            if(is.null(try)){\n                sendPopUpMessage(\"ERROR occoured!\")\n            }\n            else\n            {\n                tmp <- tmp$x.alr\n                oldNames <- names(tmp)\n                newNames <- c()\n                for(i in (1:length(oldNames))){\n                    newNames[i] <- paste0(oldNames[i], '_', options$ivarName)\n                }\n                tmp <- as.data.frame(tmp)\n                names(tmp) <- newNames\n                data <- as.data.frame(variablesEnv$currentData)\n                eval(parse(text = paste0('data@transformations$', as.character(options$name), '<- as.data.frame(tmp)')))\n\n                variablesEnv$currentData <- data\n                renderDataInformation(createJSObject())\n                sendPopUpMessage('Transformation successfully done!')\n                resetConnector('addLR')\n                setDataAndGroup(variablesEnv$currentDataName, options$name, options$subset)\n            }\n        }\n    })\n\n########################################################## cenLR ######################################################################\n    observe({\n        options <- input$cenLR\n        if(!is.null(options)){\n            data <- as.data.frame(variablesEnv$currentData)\n            variablesEnv$currentVariableGroup <- (as.numeric(unlist(options$variablesGroup)) + 1)\n            if(length(options$variablesGroup) != 0){\n                data <- data[variablesEnv$currentVariableGroup]\n            }\n\n            try <- tryCatch({eval(parse(text = 'tmp <- cenLR(x = data)'))}, error = function(cond){return(NULL)})\n\n            if(is.null(try)){\n                sendPopUpMessage(\"ERROR occoured!\")\n            }\n            else\n            {\n                tmp <- tmp$x.clr\n                oldNames <- names(tmp)\n                newNames <- c()\n                for(i in (1:length(oldNames))){\n                    newNames[i] <- paste0(oldNames[i],'_clr')\n                }\n\n                names(tmp) <- newNames\n                data <- as.data.frame(variablesEnv$currentData)\n                eval(parse(text = paste0('data@transformations$', as.character(options$name), '<- as.data.frame(tmp)')))\n\n                variablesEnv$currentData <- data\n                renderDataInformation(createJSObject())\n                sendPopUpMessage('Transformation successfully done!')\n                resetConnector('cenLR')\n                setDataAndGroup(variablesEnv$currentDataName, options$name, options$subset)\n            }\n\n        }\n    })\n\n########################################################## isomLR ######################################################################\n    observe({\n        options <- input$isomLR\n        if(!is.null(options)){\n            data <- as.data.frame(variablesEnv$currentData)\n            variablesEnv$currentVariableGroup <- (as.numeric(unlist(options$variablesGroup)) + 1)\n            if(length(options$variablesGroup) != 0){\n                data <- data[variablesEnv$currentVariableGroup]\n            }\n\n            try <- tryCatch({eval(parse(text = 'tmp <- isomLR(x = data)'))}, error = function(cond){return(NULL)})\n            if(is.null(try)){\n                sendPopUpMessage(\"ERROR occoured!\")\n            }\n            else\n            {\n                tmp <- as.data.frame(tmp)\n                oldNames <- names(tmp)\n                newNames <- c()\n                for(i in (1:length(oldNames))){\n                    newNames[i] <- paste0('ilr_', i)\n                }\n\n                names(tmp) <- newNames\n                data <- as.data.frame(variablesEnv$currentData)\n                eval(parse(text = paste0('data@transformations$', as.character(options$name), '<- as.data.frame(tmp)')))\n\n                variablesEnv$currentData <- data\n                renderDataInformation(createJSObject())\n                sendPopUpMessage('Transformation successfully done!')\n                resetConnector('isomLR')\n                setDataAndGroup(variablesEnv$currentDataName, options$name, options$subset)\n            }\n\n\n\n        }\n    })\n############################################################ command #####################################################################\n    observe({\n        options <- input$transformationCommand\n        if(!is.null(options)){\n            data <- as.data.frame(variablesEnv$currentData)\n            variablesEnv$currentVariableGroup <- (as.numeric(unlist(options$variablesGroup)) + 1)\n            if(length(options$variablesGroup) != 0){\n                data <- data[variablesEnv$currentVariableGroup]\n            }\n\n            try <- tryCatch({eval(parse(text = paste0('tmp <-', options$command ,'(data)')))}, error = function(cond){return(NULL)})\n            if(is.null(try)){\n                sendPopUpMessage(\"ERROR: chosen method does not exist or can\\'t be applied on chosen data!\")\n            }\n            else{\n                oldNames <- names(tmp)\n                newNames <- c()\n                for(i in (1:length(oldNames))){\n                    newNames[i] <- paste0(oldNames[i], '_', options$command)\n                }\n                names(tmp) <- newNames\n                data <- as.data.frame(variablesEnv$currentData)\n                eval(parse(text = paste0('data@transformations$', as.character(options$name), '<- as.data.frame(tmp)')))\n\n                variablesEnv$currentData <- data\n                renderDataInformation(createJSObject())\n                sendPopUpMessage('Transformation successfully done!')\n                resetConnector('log')\n                setDataAndGroup(variablesEnv$currentDataName, options$name, options$subset)\n            }\n        }\n    })\n\n#######################################################################################################################################\n################################################### DEFINE NEW VARIABLES GROUP ########################################################\n#######################################################################################################################################\n\n    observe({\n        options <- input$newDefinedVariablesGroups\n        if(!is.null(options)){\n            data <- variablesEnv$currentData\n            groupNames <- names(options)\n            groupNames <- groupNames[-length(groupNames)]\n            if(options$type == \"transformations\"){\n                nrow = options[1]\n                eval(parse(text = paste0('nrow <- nrow$', groupNames[1])))\n                nrow <- nrow[as.character((names(nrow)[1]))]\n                eval(parse(text = paste0('nrow <- nrow$', names(nrow))))\n                nrow[unlist(lapply(nrow, is.null))] <- NA\n                nrow <- length(unlist(nrow))\n\n                for(i in (1: length(groupNames))){\n                    tmpOptions <- options[i]\n                    eval(parse(text = paste0('tmpOptions <- tmpOptions$', groupNames[i])))\n                    names <- names(tmpOptions)\n                    tmp <- matrix(0, ncol = length(names), nrow = nrow)\n                    tmp <- as.data.frame(tmp)\n                    names(tmp) <- names\n\n                    for(j in (1:length(names))){\n                        currentTmpOptions <- tmpOptions[as.character(names[j])]\n                        eval(parse(text = paste0('currentTmpOptions <- currentTmpOptions$', names(currentTmpOptions))))\n                        currentTmpOptions[unlist(lapply(currentTmpOptions, is.null))] <- NA\n                        eval(parse(text = paste0('tmp[', j, '] <-', as.vector(unlist(currentTmpOptions)))))\n                    }\n                    data@transformations[[as.character(groupNames[i])]] <- tmp\n                }\n            }else{\n                for(i in (1:length(groupNames))){\n                    variables <- unlist(options[i])\n                    if(options$type == \"comp\"){\n                        data@compositions[[groupNames[i]]] <- variables\n                    }\n                    else if(options$type == \"extern\"){\n                        data@externals[[groupNames[i]]] <- variables\n                    }\n                    else if(options$type == \"coord\"){\n                        data@coords[[groupNames[i]]] <- variables\n                    }\n                    else{\n                        data@ids[[groupNames[i]]] <- variables\n                    }\n                }\n            }\n            variablesEnv$currentData <- data\n            sendPopUpMessage('New data variables groups were successfully created!')\n            resetConnector('newDefinedVariablesGroups')\n        }\n    })\n\n#######################################################################################################################################\n################################################# DEFINE NEW OBSERVATIONS GROUP #######################################################\n#######################################################################################################################################\n################################################################ COMMAND ##############################################################\n    observe({\n        options <- input$defineObservationsCommand\n        if(!is.null(options)){\n            commands <- as.vector(unlist(options$commands))\n            data <- variablesEnv$currentData\n            attach(data)\n            indexes <- c()\n            for(i in (1 : length(commands))){\n                try <- tryCatch({indexes <- c(indexes, eval(parse(text = paste0('which(', commands[i], ')'))))}, error = function(cond){return(NULL)})\n                if(is.null(try)){\n                    sendPopUpMessage('Invalid command!');\n                    detach(data)\n                    return(NULL);\n                }\n            }\n            indexes <- unique(indexes)\n            indexes <- sort(indexes) - 1\n\n            data@subsets[[options$name]] <- indexes\n\n            detach(data)\n            variablesEnv$currentData <- data\n\n            sendPopUpMessage('Observation group was successfully defnined!')\n            renderDataInformation(createJSObject())\n            setDataAndGroup(variablesEnv$currentDataName, options$group, options$name)\n            resetConnector('defineObservationsCommand')\n        }\n    })\n\n################################################################ FACTOR ##############################################################\n\n    observe({\n        options <- input$defineObservationsFactor\n        if(!is.null(options)){\n           data <- variablesEnv$currentData\n            subsetNames <- names(options)\n            for(i in (1: length(subsetNames))){\n                indexes <- unlist(options[i])\n                data@subsets[[subsetNames[i]]] <- indexes\n            }\n            variablesEnv$currentData <- data\n\n            sendPopUpMessage('Observation group(s) was successfully defnined!')\n            resetConnector('defineObservationsFactor')\n        }\n    })\n\n########################################################################################################################################\n################################################################### Statistical Methods ################################################\n########################################################################################################################################\n############################################################## PCA #####################################################################\n    observe({\n      \n      options <- input$pca.in\n      if(!is.null(options)){\n        \n        data <- as.data.frame(variablesEnv$currentData)\n        \n        variablesEnv$currentVariableGroup <- (as.numeric(unlist(options$groupData)) + 1)\n        if(length(options$groupData) != 0){\n          data <- data[variablesEnv$currentVariableGroup]\n        }\n        if(options$type == 'compositions'){\n          \n          \n          if(options$method == 'robust'){\n            try <- tryCatch({tmp <- pcaCoDa(USArrests, method = 'robust')},\n                            error = function(cond){return(NULL)})\n            \n          }\n          else if (options$method == 'standard'){\n            try <- tryCatch({tmp <- pcaCoDa(USArrests, method = 'standard')},\n                            error = function(cond){return(NULL)})\n          }\n          else{\n            sendPopUpMessage(paste0('ERROR: method \"', options$method, '\" is not supported' ))\n          }\n          \n        }\n        else if(options$type == 'externals'){\n          \n          if(options$method == 'robust'){\n            try <- tryCatch({tmp <- prcomp(data,scale=options$scale, covmat =covPCAproj(data)$cov )},\n                            error = function(cond){return(NULL)})\n            \n          }\n          else if (options$method == 'standard'){\n            try <- tryCatch({tmp <- prcomp(data,scale=options$scale)},\n                            error = function(cond){return(NULL)})\n          }\n          else{\n            sendPopUpMessage(paste0('ERROR: method \"', options$method, '\" is not supported' ))\n          }\n          \n        }\n        else{\n          sendPopUpMessage(paste0('ERROR: type \"', options$type, '\" is not supported' ))\n        }\n        \n        if(is.null(try)){\n          sendPopUpMessage(\"ERROR: chosen method does not exist or can\\'t be applied on chosen data!\")\n        }\n        else{\n          \n          if(options$showScores){\n            output$pca.Score <- renderPrint({\n              print(summary(tmp))\n              \n            })\n          }\n          \n          if(options$type == 'compositions'){\n            output$pca.BiPlot <- renderPlot({\n              plot(tmp)\n            })\n            \n          }\n          else{\n            output$pca.BiPlot <- renderPlot({\n              ggbiplot(tmp, labels =  rownames(tmp))\n            })\n            \n            output$pca.ScreePlot <- renderPlot({\n              #data(USArrests)\n              #plot(prcomp(USArrests,scale=TRUE), type = 'l')\n              screeplot(tmp, type = 'l')\n            })\n          }\n          \n        }\n        \n      }\n      \n    })\n\n    \n    ############################################################## ClusterAnalysis #####################################################################\n    \n    observe({\n      \n      options <- input$clust.in\n      if(!is.null(options)){\n        \n        data <- as.data.frame(variablesEnv$currentData)\n        \n        variablesEnv$currentVariableGroup <- (as.numeric(unlist(options$groupData)) + 1)\n        if(length(options$groupData) != 0){\n          data <- data[variablesEnv$currentVariableGroup]\n        }\n        if(options$variant == 'hierarchic'){\n          if(options$type == 'ward'){\n            \n            \n            \n          }\n          else if(options$type == 'ward.D2'){\n            \n            \n            \n          }\n          else{\n            sendPopUpMessage(paste0('ERROR: type \"', options$type, '\" is not supported' ))\n          }\n          \n          \n        }\n        else if(options$variant == 'partitioning'){\n          \n          if(options$type == 'kmeans'){\n            \n            \n            \n          }\n          else if(options$type == 'mclust'){\n            \n            \n            \n          }\n          else{\n            sendPopUpMessage(paste0('ERROR: type \"', options$type, '\" is not supported' ))\n          }\n          \n        }\n        else{\n          sendPopUpMessage(paste0('ERROR: variant \"', options$variant, '\" is not supported' ))\n        }\n        \n        if(is.null(try)){\n          sendPopUpMessage(\"ERROR: chosen method does not exist or can\\'t be applied on chosen data!\")\n        }\n        else{\n          \n          \n          \n        }\n        \n      }\n      \n    })  \n    \n    \n    ############################################################## Regression #####################################################################\n    \n    observe({\n      \n      options <- input$regression.in\n      if(!is.null(options)){\n        \n        #\n        dataAll <- variablesEnv$currentData\n        \n        data <- dataAll[which(names(dataAll)==options$dependentVariable)]\n        for ( i in 1:(length(names(dataAll))) ) {\n            if(length(which(names(dataAll)==options$variablesdName[i]))>0){\n              data[options$variablesdName[[i]]] <- (dataAll[which(names(dataAll)==options$variablesdName[i])])\n            }\n        }\n\n        \n        #eval(parse(text = paste0('data <- data[c(data', options$dependentVariable,',',paste(options$variablesdName,collapse=\",\"),')]')))\n        \n        if(options$log){\n          temdata <- log(data)\n        }\n        else{\n          temdata <- data\n        }\n        rapply( temdata, f=function(x) ifelse(is.infinite(x),0,x), how=\"replace\" )\n        rapply( temdata, f=function(x) ifelse(is.nan(x),0,x), how=\"replace\" )\n        rapply( temdata, f=function(x) ifelse(is.finite(x),0,x), how=\"replace\" )\n\n        variablesEnv$currentVariableGroup <- (as.numeric(unlist(options$groupData)) + 1)\n        if(length(options$groupData) != 0){\n          temdata <- data[variablesEnv$currentVariableGroup]\n        }\n        \n        #dependentVariable\n        #variablesdName\n        #which(names(ice)==\"x2\")\n        \n        variablesdName <- paste(options$variablesdName,collapse=\"+\")\n        \n        \n        if(options$regressionMethod == 'lm'){\n          #eval(parse(text = paste0('tmp <- lm(', options$dependentVariable,' ~ ',variablesdName,', data = unclass(temdata))')))\n          try <- tryCatch({eval(parse(text = paste0('tmp <- lm(', options$dependentVariable,' ~ ',variablesdName,', data = unclass(temdata))')))},\n                         error = function(cond){return(NULL)})\n          \n        }\n        \n        else if(options$regressionMethod == 'lmrob'){\n          try <- tryCatch({eval(parse(text = paste0('tmp <- lmrob(', options$dependentVariable,' ~ ',variablesdName,', data = unclass(temdata))')))},\n                          error = function(cond){return(NULL)})\n        }\n        \n        else if(options$regressionMethod == 'ltsReg'){\n          try <- tryCatch({eval(parse(text = paste0('tmp <- ltsReg(', options$dependentVariable,' ~ ',variablesdName,', data = unclass(temdata))')))},\n                          error = function(cond){return(NULL)})\n        }\n        \n        \n        \n        \n        tes <- options$variablesdName \n        output$regression.Plot <- renderPlot({\n          eval(parse(text = paste0('ggplot((temdata), aes( ', options$x ,',',options$y,')) + geom_point()  + geom_abline(intercept=',tmp$coefficients[1] ,', slope=',tmp$coefficients[which(names(tmp$coefficients)==options$x)],' )')))\n        })\n        \n        \n        #renderPrint\n        output$click_info <- renderDataTable({\n          nearPoints(temdata, input$regression.Plot_click)\n        },options=list(\n          paging = FALSE,\n          searching = FALSE))\n        \n        #renderPrint\n        output$brush_info <- renderDataTable({\n          \n          brushedPoints(temdata, input$regression.Plot_brush) \n        })\n        \n        output$render.tes <- renderPrint({\n          print(data)\n        })\n        \n      }\n      \n    })  \n    \n\n#######################################################################################################################################\n################################################################ PLOT #################################################################\n#######################################################################################################################################\n############################################################## BAR-PLOT ###############################################################\n############################################################ VARIABLES ################################################################\n observe({\n    options <- input$variablesBarPlot\n    if(!is.null(options)){\n        data <- variablesEnv$currentData\n        variables <- c()\n        if(options$variablesType == 'transformations'){\n            data <- getVariables(options$variablesType, options$variablesName)\n        }else{\n            variables <- getVariables(options$variablesType, options$variablesName)\n        }\n\n        if(length(variables) > 0){\n            data <- data[, variables]\n        }\n\n        if(options$useSubset && length(options$currentSubset) > 0){\n            subset <- unlist(options$currentSubset) + 1\n            data <- data[subset,]\n        }\n        results <- list()\n        names <- names(data)\n        for(i in 1:length(data)){\n            try <- tryCatch({eval(parse(text = paste0('results[[names[i]]] <- ',options$method, '(data[,i])' )))},\n                            error = function(cond){return(NULL)})\n\n            if(is.null(try) || length(results[[names[i]]]) > 1){\n                sendPopUpMessage(paste0('ERROR: method \"', options$method, '\" is not supported' ))\n                resetConnector('variablesBarPlot')\n                return(NULL)\n            }\n        }\n        message = list()\n        message[['title']] <- options$title\n        message[['yAxis']] <- options$yAxis\n        message[['data']] <- results\n        session$sendCustomMessage(type ='plotBarPlot', message = message)\n        resetConnector('variablesBarPlot')\n    }\n })\n\n\n########################################################################################################################################\n############################################################## GROUP BAR PLOT ##########################################################\n########################################################################################################################################\nobserve({\n    options <- input$groupBarPlot\n    if(!is.null(options)){\n        data <- variablesEnv$currentData\n        factors <- unlist(data[options$factor])\n        uniqueFactors <- unique(factors)\n        variables <- c()\n\n        if(options$variablesType == 'transformations'){\n            data <- getVariables(options$variablesType, options$variablesName)\n        }else{\n            variables <- getVariables(options$variablesType, options$variablesName)\n        }\n\n        if(length(variables) > 0){\n            data <- data[, variables]\n        }\n\n        names <- names(data)\n        if(options$useSubset && length(options$currentSubset) > 0){\n            subset <- unlist(options$currentSubset) + 1\n            data <- data[subset,]\n        }\n\n        results <- list()\n        notToUseIndexes <- c()\n        for(i in 1:length(uniqueFactors)){\n            indexes <- which(factors == uniqueFactors[i])\n            tmpResult <- c()\n            verifInd <- 1\n            for(j in 1:length(names)){\n                if(is.numeric(unlist(data[names[j]]))){\n                    tmpData <- data[names[j]]\n\n                    tmpData <- tmpData[indexes, ]\n\n                    tmpData <- tmpData[complete.cases(tmpData)]\n\n                    try <- tryCatch({eval(parse(text = paste0('tmpResult <- c(tmpResult,', options$method, '(tmpData))')))},\n                            error = function(cond){return(NULL)})\n\n                    if(is.null(try) || (verifInd == 1 && length(tmpResult) > 1)){\n                        sendPopUpMessage(paste0('ERROR: method \"', options$method, '\" is not supported' ))\n                        resetConnector('groupBarPlot')\n                        return(NULL)\n                    }\n                    \n                    verifInd <- verifInd + 1\n                }else{\n                    notToUseIndexes <- c(notToUseIndexes, j)\n                }\n            }\n\n            results[[uniqueFactors[i]]] <- tmpResult\n        }\n\n        if(is.null(results) || length(results) == 0){\n            sendPopUpMessage('ERROR: chosen data can\\'t be ploted')\n            return(NULL)\n        }\n        results <- as.data.frame(results)\n        names(results) <- uniqueFactors\n        if(!is.null(notToUseIndexes)){\n            names <- names[-notToUseIndexes]\n        }\n        message <- list()\n        message[[\"data\"]] <- results\n        message[[\"names\"]] <- names\n        message[['title']] <- options$title\n        message[['yAxis']] <- options$yAxis\n\n        session$sendCustomMessage(type = 'plotGroupBarPlot', message = message)\n        resetConnector('groupBarPlot')\n    }\n\n})\n\n\n########################################################################################################################################\n################################################################ BOXPLOT ###############################################################\n########################################################################################################################################\n################################################################# FACTORS ##############################################################\n observe({\n    options <- input$boxPlotFactor\n    if(!is.null(options)){\n        data <- variablesEnv$currentData\n        factors <- unlist(data[options$factor])\n        uniqueFactors <- unique(factors)\n\n        try <- tryCatch({data <- data[options$variable]}, error = function(cond){return(NULL)})\n        if(is.null(try)){\n            data <- getVariableFromTransformation(options$variable)\n            if(is.null(data)){\n                sendPopUpMessage(paste0('ERROR: variable \"', options$variable,'\" doesn\\'t exist on this data-set!'))\n                return(NULL)\n            }\n        }\n        str(data)\n        dataLength <- length(data[,1])\n        if(options$method != \"\"){\n            try <- tryCatch({eval(parse(text = paste0('data <- ', options$method,'(data)')))},\n                        error = function(cond){return(NULL)})\n            str(data)\n            if(is.null(try) || length(data[,1]) != dataLength){\n                sendPopUpMessage(paste0('ERROR! function \"', options$method, '\" is not supported!'))\n                return(NULL)\n            }\n        }\n\n        if(options$useSubset && length(options$currentSubset) > 0){\n           subset <- unlist(options$currentSubset) + 1\n            data <- as.data.frame(data[subset,])\n        }\n\n        results <- list()\n        upperOutliers <- list()\n        lowerOutliers <- list()\n        for(i in 1:length(uniqueFactors)){\n            indexes <- which(factors == uniqueFactors[i])\n            tmpData <- data[indexes,]\n            tmpData <- tmpData[complete.cases(tmpData)]\n\n            try <- tryCatch({box <- boxplot(tmpData, plot=F)}, error = function(cond){return(NULL)})\n            if(is.null(try)){\n                sendPopUpMessage('ERROR: something went wrong!')\n                return(NULL)\n            }else{\n                results[[uniqueFactors[i]]] <- as.vector(box$stats)\n                upperOut <- as.vector(tmpData[tmpData > box$stats[5]])\n                if(length(upperOut) > 0){\n                    upperOutliers[[uniqueFactors[i]]] <- as.vector(upperOut)\n                }else\n                {\n                    upperOutliers[[uniqueFactors[i]]] <- as.list(\"no\")\n                }\n                lowerOut <- as.vector(tmpData[tmpData < box$stats[1]])\n                if(length(lowerOut) > 0){\n                    lowerOutliers[[uniqueFactors[i]]] <- as.vector(lowerOut)\n                }else{\n                    lowerOutliers[[uniqueFactors[i]]] <- as.list(\"no\")\n                }\n            }\n        }\n        names(results) <- uniqueFactors\n        names(upperOutliers) <- uniqueFactors\n        names(lowerOutliers) <- uniqueFactors\n\n        message <- list()\n        message[['results']] <- results\n        message[['upperOutliers']] <- upperOutliers\n        message[['lowerOutliers']] <- lowerOutliers\n        message[['categories']] <- uniqueFactors\n        message[['title']] <- options$title\n\n        session$sendCustomMessage(type = 'plotBoxPlot', message = message)\n        resetConnector('boxPlotFactor')\n    }\n })\n\n ############################################################### VARIABLES ###########################################################\n observe({\n    options <- input$boxPlotVariables\n    if(!is.null(options)){\n        data <- variablesEnv$currentData\n        variables <- c()\n\n        if(options$variablesType == 'transformations'){\n            data <- getVariables(options$variablesType, options$variablesName)\n        }else{\n            variables <- getVariables(options$variablesType, options$variablesName)\n        }\n\n        if(length(variables) > 0){\n            data <- data[, variables]\n         }\n\n        names <- names(data)\n        if(options$useSubset && length(options$currentSubset) > 0){\n            subset <- unlist(options$currentSubset) + 1\n            data <- data[subset,]\n        }\n\n        results <- list()\n        upperOutliers <- list()\n        lowerOutliers <- list()\n        for(i in 1:length(names)){\n            tmpData <- data[names[i]]\n\n            try <- tryCatch({box <- boxplot(tmpData, plot=F)}, error = function(cond){return(NULL)})\n            if(is.null(try)){\n                sendPopUpMessage('ERROR: something went wrong!')\n                return(NULL)\n            }else{\n                results[[names[i]]] <- as.vector(box$stats)\n                upperOut <- as.vector(tmpData[tmpData > box$stats[5]])\n                if(length(upperOut) > 0){\n                    upperOutliers[[names[i]]] <- upperOut\n                }else\n                {\n                    upperOutliers[[names[i]]] <- as.list(\"no\")\n                }\n                lowerOut <- as.vector(tmpData[tmpData < box$stats[1]])\n                if(length(lowerOut) > 0){\n                    lowerOutliers[[names[i]]] <- lowerOut\n                }else{\n                    lowerOutliers[[names[i]]] <- as.list(\"no\")\n                }\n            }\n        }\n        names(results) <- names\n        names(upperOutliers) <- names\n        names(lowerOutliers) <- names\n\n        message <- list()\n        message[['results']] <- results\n        message[['upperOutliers']] <- upperOutliers\n        message[['lowerOutliers']] <- lowerOutliers\n        message[['categories']] <- names\n        message[['title']] <- options$title\n\n        session$sendCustomMessage(type = 'plotBoxPlot', message = message)\n        resetConnector('boxPlotVariables')\n    }\n })\n\n\n\n})\n\n",
    "created" : 1442069651313.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1281747440",
    "id" : "1AAEA843",
    "lastKnownWriteTime" : 1444120603,
    "path" : "C:/Users/Jakob/shiny/r-shiny_v1.1/shiny/server.R",
    "project_path" : "shiny/server.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}