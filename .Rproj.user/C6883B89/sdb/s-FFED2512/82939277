{
    "contents" : "tryCatch({library(shiny)}, error = function(cond){return(NULL)})\ntryCatch({library(mvoutlier)}, error = function(cond){return(NULL)})\ntryCatch({library(robCompositions)}, error = function(cond){return(NULL)})\ntryCatch({library(VIM)}, error = function(cond){return(NULL)})\ntryCatch({library(StatDA)}, error = function(cond){return(NULL)})\ntryCatch({library(robustbase)}, error = function(cond){return(NULL)})\ntryCatch({library(MASS)}, error = function(cond){return(NULL)})\ntryCatch({library(mclust)}, error = function(cond){return(NULL)})\n\ntryCatch({library(devtools)}, error = function(cond){return(NULL)})\ntryCatch({library(robCompositions)}, error = function(cond){return(NULL)})\ntryCatch({library(ggplot2)}, error = function(cond){return(NULL)})\ntryCatch({library(ggbiplot)}, error = function(cond){return(NULL)})\ntryCatch({library(ggdendrogram)}, error = function(cond){return(NULL)})\ntryCatch({library(rrcov)}, error = function(cond){return(NULL)})\ntryCatch({library(ggfortify)}, error = function(cond){return(NULL)})\n\n\n\n\n#mvoutlier\n#robCompositions\n#ggmap\n#sp\n#rgdal\n\n\n\n\n# class gemasInfo\nsetClass(\"gemasInfo\", representation(header = 'character', comment = 'character', sample = 'character', id = 'vector', coords = 'character',\n        variable = 'character', extraction = 'character', method = 'character', UDL = 'vector', LDL = 'vector', unit = 'character'), contains = NULL)\n\n# creating the class compData and its methods\nsetClass(\"compData\", representation(compositions = \"list\", externals = \"list\", coords = \"list\", ids = \"list\", transformations = \"list\", subsets = \"list\",\n        variablesTypes = 'vector', availableGemasInfo = 'logical', gemasInfo = 'gemasInfo'), contains = \"data.frame\")\n\n# createing a enviroment for saving temporary data\nvariablesEnv <- new.env()\nassign(\"dataList\", list(), env = variablesEnv)\nassign(\"currentData\", data.frame(), env = variablesEnv)\nassign(\"currentVariableGroup\", list(), env = variablesEnv)\nassign(\"currentVariableGroupName\", character, env = variablesEnv)\nassign('currentSubset', list(), env = variablesEnv)\nassign('currentSubsetName', list(), env = variablesEnv)\nassign(\"tempData\", data.frame(), env = variablesEnv)\nassign(\"uploadPath\", NULL, env = variablesEnv)\nassign(\"name\", NULL, env = variablesEnv)\nassign(\"tempGemasInfo\", 'gemasInfo', env = variablesEnv)\nassign(\"availableGemasInfo\", 'logical', env = variablesEnv)\nassign(\"currentDataName\", NULL, env = variablesEnv)\n\nshinyServer(function(input, output, session) {\n\n###############################################################################################################################################\n################################################### VARIOUS FUNCTIONS #########################################################################\n###############################################################################################################################################\n\n    getNAs <- function(data){\n        nas <- c()\n        for(i in (1:length(names(data)))){\n            nas[i] <- sum(is.na(data[i]))\n        }\n\n        return(nas)\n    }\n\n    createJSObject <- function(){\n        temp <- variablesEnv$currentData\n        variablesEnv$currentVariableGroup <- list()\n\n        data <- list()\n        data[[\"names\"]] = names(variablesEnv$currentData)\n        Data <- as.data.frame(temp@.Data)\n        names(Data) <- names(variablesEnv$currentData)\n        data[[\"data\"]] = Data\n        data[[\"compositions\"]] = temp@compositions\n        data[[\"externals\"]] = temp@externals\n        data[[\"coords\"]] = temp@coords\n        data[[\"ids\"]] = temp@ids\n        data[[\"transformations\"]] = temp@transformations\n        data[[\"subsets\"]] = temp@subsets\n        data[[\"variablesTypes\"]] = temp@variablesTypes\n        data[[\"nas\"]] = getNAs(temp)\n        data[[\"ldl\"]] = getLDL(temp)\n        data[[\"udl\"]] = getUDL(temp)\n\n        gemasInfo <- temp@gemasInfo\n        test <- list()\n        if(length(gemasInfo@header) > 0){\n            test[[\"HEADER\"]] <- gemasInfo@header\n        }\n        if(length(gemasInfo@comment) > 0){\n            test[[\"COMMENT_DATASET\"]] <- gemasInfo@comment\n        }\n        if(length(gemasInfo@id) > 0){\n            test[[\"SAMPLE_IDENTIFIER\"]] <- gemasInfo@id\n        }\n        if(length(gemasInfo@coords) > 0){\n            test[[\"COORDINATES\"]] <- gemasInfo@coords\n        }\n        if(length(gemasInfo@variable) > 0){\n            test[[\"VARIABLE\"]] <- gemasInfo@variable\n        }\n        if(length(gemasInfo@extraction) > 0){\n            test[[\"EXTRACTION\"]] <- gemasInfo@extraction\n        }\n        if(length(gemasInfo@method) > 0){\n            test[[\"METHOD\"]] <- gemasInfo@method\n        }\n        if(length(gemasInfo@UDL) > 0){\n            test[[\"UDL\"]] <- gemasInfo@UDL\n        }\n        if(length(gemasInfo@LDL) > 0){\n            test[[\"LDL\"]] <- gemasInfo@LDL\n        }\n        if(length(gemasInfo@unit) > 0){\n            test[[\"UNIT\"]] <- gemasInfo@unit\n        }\n        data[[\"gemasInfo\"]] <- test\n        return(data)\n    }\n\n    getLDL <- function(data){\n        ldl <- c()\n        limit <- data@gemasInfo\n        limit <- limit@LDL\n        if(length(limit) > 0){\n            for(i in (1:length(names(data)))){\n                if(is.na(limit[i])){\n                    ldl[i] <- \"\"\n                }\n                else{\n                    ldl[i] <- sum(data[i] < as.numeric(limit[i]))\n                }\n            }\n        }\n\n        return(ldl)\n    }\n\n\n    getUDL <- function(data){\n        udl <- c()\n        limit <- data@gemasInfo\n        limit <- limit@UDL\n        if(length(limit) > 0){\n            for(i in (1:length(names(data)))){\n                if(is.na(limit[i])){\n                    udl[i]<- \"\"\n                }\n                else{\n                    udl[i] <- sum(data[i] > as.numeric(limit[i]))\n                }\n            }\n        }\n\n        return(udl)\n    }\n\n    sendPopUpMessage <- function(textMessage){\n        session$sendCustomMessage(type = 'popUpMessage', message = textMessage)\n    }\n\n    createDataSelector <- function(names){\n        session$sendCustomMessage(type = 'createDataSelector', message = names)\n    }\n\n    renderDataInformation <- function(data){\n        session$sendCustomMessage(type = 'renderDataInformation', message = data)\n    }\n\n    resetConnector <- function(connectorName){\n        session$sendCustomMessage(type = 'resetConnector', message = connectorName)\n    }\n\n    setDataAndGroup <- function(fileName, groupName, subsetName){\n            names = c();\n            names[[\"fileName\"]] = fileName\n            names[[\"groupName\"]] = groupName\n            names[[\"subsetName\"]] = subsetName\n            session$sendCustomMessage(type = 'setSelectorsValue', message = names)\n    }\n\n    addNewDataToDataList <- function(newName, newData){\n        eval(parse(text = paste0(\"variablesEnv$dataList$\", variablesEnv$currentDataName ,\"<- variablesEnv$currentData\")))\n        eval(parse(text = paste0(\"variablesEnv$dataList$\",newName ,\"<-\", as.data.frame(newData))))\n        createDataSelector(as.list(names(variablesEnv$dataList)))\n        variablesEnv$currentDataName <- newName\n        variablesEnv$currentData <- newData\n    }\n\n    getAllIdAndCoordIndexes <- function(){\n        indexes <- c()\n        data <- variablesEnv$currentData\n        ids <- data@ids\n        coords <- data@coords\n        if(length(ids) > 0){\n            names <- names(ids)\n            for(i in 1:length(names)){\n                eval(parse(text = paste0('indexes <- c(indexes,ids$',names[i], ')')))\n            }\n        }\n\n        if(length(coords) > 0){\n            names <- names(coords)\n            for(i in 1:length(names)){\n                eval(parse(text = paste0('indexes <- c(indexes,coords$',names[i], ')')))\n            }\n        }\n\n        indexes <- unique(indexes) + 1\n\n        return(indexes)\n    }\n\n    getVariables <- function(variablesType, variablesName){\n        data <- variablesEnv$currentData\n        if(variablesType == \"compositions\"){\n            compositions <- data@compositions\n            return(as.vector(eval(parse(text = paste0('compositions$', variablesName))) + 1))\n        }else if(variablesType == \"externals\"){\n            externals <- data@externals\n            return(as.vector(eval(parse(text = paste0('externals$', variablesName))) + 1))\n        }else if(variablesType == \"coords\"){\n            coords <- data@coords\n            return(as.vector(eval(parse(text = paste0('coords$', variablesName))) + 1))\n        }else if(variablesType == \"ids\"){\n             ids <- data@ids\n             return(as.vector(eval(parse(text = paste0('ids$', variablesName))) + 1))\n        }else if(variablesType == \"transformations\"){\n              return(as.data.frame(data@transformations[as.character(variablesName)]))\n        }\n    }\n\n    updateVariables <- function(variablesType, variablesName, variables){\n        data <- variablesEnv$currentData\n        if(variablesType == \"compositions\"){\n             compositions <- data@compositions\n             compositions[[variablesName]] <- variables\n             data@compositions <- compositions\n        }else if(variablesType == \"externals\"){\n             externals <- data@externals\n             externals[[variablesName]] <- variables\n             data@externals <- externals\n        }else if(variablesType == \"coords\"){\n             coords <- data@coords\n             coords[[variablesName]] <- variables\n             data@coords <- coords\n        }else if(variablesType == \"ids\"){\n              ids <- data@ids\n              ids[[variablesName]] <- variables\n              data@ids <- ids\n        }\n        return(data)\n    }\n\n    getVariableFromTransformation <- function(variableName){\n        data <- variablesEnv$currentData\n        data <- data@transformations\n        names <- names(data)\n        variable <- NULL\n        for(i in 1:length(names)){\n            tmpTrans <- eval(parse(text = paste0('data$', names[i])))\n            try <- tryCatch({variable <- tmpTrans[variableName]}, error = function(cond){return(NULL)})\n            if(!is.null(try)){\n                break;\n            }\n        }\n\n        return(variable)\n    }\n\n###############################################################################################################################################\n####################################################### DATA UPLOAD ###########################################################################\n###############################################################################################################################################\n\n    session$sendCustomMessage(type = 'allRPackages', message = sort(installed.packages()[,1]))\n    createDataSelector(as.list(names(variablesEnv$dataList)))\n\n  observe({\n      file <- input$uploadCSVFile\n      if(!is.null(file)){\n        variablesEnv$uploadPath <- file$datapath\n\n        session$sendCustomMessage(type = \"createCSVFileOptionDialog\", message = file$name)\n\n      }\n  })\n\n  observe({\n    file <- input$uploadRData\n    if(!is.null(file)){\n        variablesEnv$uploadPath <- file$datapath\n        variablesEnv$tempData <- load(file$datapath)\n        variablesEnv$tempData <- eval(parse(text = variablesEnv$tempData[1]))\n        if(!is.null(variablesEnv$tempData)){\n            variablesEnv$uploadPath <- NULL\n            variablesEnv$availableGemasInfo <- FALSE\n            session$sendCustomMessage(type = \"createFileOptionDialog\", message = file$name)\n        }\n    }\n  })\n\n  observe({\n    if(!is.null(input$preview)){\n        options <- input$preview\n        if(!is.null(variablesEnv$uploadPath)){\n\n            try <- tryCatch({variablesEnv$tempData <- read.table(variablesEnv$uploadPath, nrows = 15, header = options$header,\n                                                                sep = options$separator, dec = options$decimal,\n                                                                quote = options$quotes)},\n                            error = function(cond){return(NULL)})\n\n            if(is.null(try)){\n                sendPopUpMessage('ERROR: corrupted file!')\n                return(NULL)\n            }\n        }\n\n            session$sendCustomMessage(type = 'createPreviewTable', message = variablesEnv$tempData)\n        }\n  })\n\n  observe({\n    if(!is.null(input$uploadChosenFile)){\n        options <- input$uploadChosenFile\n        if(!is.null(variablesEnv$uploadPath)){\n            tmp <- readLines(variablesEnv$uploadPath, n = 30)\n            tmp <- tmp[substr(tmp, 1, 1) != '#']\n\n            if(csvWithInfo(tmp[1]) == FALSE){\n                variablesEnv$availableGemasInfo <- FALSE\n                variablesEnv$tempData <- read.table(variablesEnv$uploadPath, header = options$header,\n                        sep = options$separator, dec = options$decimal,\n                        quote = options$quotes)\n            }else{\n                variablesEnv$availableGemasInfo <- TRUE\n                import <- importGemasCSV(options)\n\n                if(is.null(import)){\n                    resetConnector('uploadCSVFile')\n                    return(NULL)\n                }\n            }\n        }\n        variablesEnv$name <- options$name\n        data <- list()\n        data[[\"data\"]] <- variablesEnv$tempData\n        data[[\"names\"]] <- names(variablesEnv$tempData)\n        session$sendCustomMessage(type = 'createChooseVariableDialog', message = data)\n     }\n  })\n\n  csvWithInfo <- function(firstEntry){\n    if(length(grep('HEADER', firstEntry)) != 0){\n        return(TRUE);\n    }\n    else if(length(grep('COMMENT DATASET', firstEntry)) != 0){\n         return(TRUE);\n    }\n    else if(length(grep('SAMPLE IDENTIFIER', firstEntry)) != 0){\n        return(TRUE);\n    }\n    else if(length(grep('COORDINATES', firstEntry)) != 0){\n        return(TRUE);\n    }\n    else if(length(grep('VARIABLE', firstEntry)) != 0){\n        return(TRUE);\n    }\n    else if(length(grep('UNIT', firstEntry)) != 0){\n        return(TRUE);\n    }\n    else if(length(grep('EXTRACTION', firstEntry)) != 0){\n        return(TRUE);\n    }\n    else if(length(grep('METHOD', firstEntry)) != 0){\n        return(TRUE);\n    }\n    else if(length(grep('UDL', firstEntry)) != 0)\n    {\n        return(TRUE);\n    }\n    else if(length(grep('LDL', firstEntry)) != 0){\n        return(TRUE);\n    }\n    else if(length(grep('COMMENT VARIABLES', firstEntry)) != 0){\n        return(TRUE);\n    }\n    else{\n        return(FALSE);\n    }\n  }\n\n  importGemasCSV <- function(options){\n\n    try <- tryCatch({tmp <- read.table(variablesEnv$uploadPath, header = T, sep = options$separator, dec = options$decimal, quote = options$quotes)},\n                          error = function(cond){return(NULL)})\n\n    if(is.null(try)){\n        sendPopUpMessage('ERROR: corrupted-file')\n        return(NULL);\n    }\n\n    skip <- (1:length(tmp[,1]))[tmp[,1]==\"\"][1]\n\n   try <- tryCatch({tmp <- read.table(variablesEnv$uploadPath, header = T, sep = options$sep, dec = options$decimal, quote = options$quotes, skip = skip)},\n                    error = function(cond){return(NULL)})\n\n\n    if(is.null(try)){\n        sendPopUpMessage('ERROR: corrupted-file')\n        return(NULL);\n    }\n\n\n    colNames <- names(tmp[\"VARIABLE\"==tmp[,1],])\n\n    try <- tryCatch({tmp <- read.table(variablesEnv$uploadPath, header = F,\n                      sep = options$separator, dec = options$decimal,\n                      quote = options$quotes)}, error=function(cond){return(NULL)})\n\n\n    if(is.null(try)){\n        sendPopUpMessage('ERROR: corrupted-file')\n        return(NULL);\n    }\n\n    tmp <- as.matrix(tmp)\n\n    gemasInfo <- new(\"gemasInfo\")\n  for ( i in 1:skip ) {\n    l <- tmp[i,]\n    print(l[1])\n    if( l[1]==\"HEADER\" ) {\n      gemasInfo@header <- paste(l[-1],sep=\"\",collapse=\"\")\n      print(gemasInfo@header)\n      }\n    if( l[1]==\"COMMENT DATASET\" ) {\n      gemasInfo@comment <- paste(l[-1],sep=\"\",collapse=\"\")\n      print(gemasInfo@comment)\n      }\n    if( l[1]==\"SAMPLE IDENTIFIER\" ) {\n      gemasInfo@id <- as.vector(l[-1])\n      print(gemasInfo@id)\n      }\n    if( l[1]==\"COORDINATES\" ) {\n      gemasInfo@coords <- as.vector(l[-1])\n      print(gemasInfo@coords)\n      }\n    if( l[1]==\"VARIABLE\" ) {\n      gemasInfo@variable <- colNames\n      print(gemasInfo@variable)\n      }\n    if( l[1]==\"UNIT\" ) {\n    print(class(l[-1]))\n      gemasInfo@unit <- as.vector(l[-1])\n      print(gemasInfo@unit)\n      }\n    if( l[1]==\"EXTRACTION\" ) {\n      gemasInfo@extraction <- as.vector(l[-1])\n      print(gemasInfo@extraction)\n      }\n    if( l[1]==\"METHOD\" ) {\n      gemasInfo@method <- as.vector(l[-1])\n      print(gemasInfo@method)\n      }\n    if( l[1]==\"UDL\" ) {\n      gemasInfo@UDL <- as.numeric(l[-1])\n      print(gemasInfo@UDL)\n      }\n    if( l[1]==\"LDL\" ) {\n      gemasInfo@LDL <- as.numeric(l[-1])\n      print(gemasInfo@LDL)\n      }\n    if( l[1]==\"COMMENT VARIABLES\" ) {\n      comment_var <- as.vector(l[-1])\n      print(comment_var)\n      }\n    }\n\n    if ( !is.na(gemasInfo@id[1]) ) gemasInfo@id <- colNames[gemasInfo@id != \"\"]\n    if ( length(gemasInfo@id) != 1 ) gemasInfo@id <- NA\n    xcoo <- colNames[ gemasInfo@coords == \"XCOO\" ]\n    if ( length(xcoo) != 1 ) xcoo <- NA\n    ycoo <- colNames[ gemasInfo@coords == \"YCOO\" ]\n    if ( length(ycoo) != 1 ) ycoo <- NA\n    gemasInfo@coords <- c(xcoo,ycoo)\n    str(gemasInfo)\n    variablesEnv$tempGemasInfo <- gemasInfo\n\n    try <- tryCatch({variablesEnv$tempData <- read.table(variablesEnv$uploadPath, header = T,\n                                        sep = options$separator, dec = options$decimal,\n                                        quote = options$quotes, skip = skip)}, error = function(cond){return(NULL)})\n\n    if(is.null(try)){\n        sendPopUpMessage('ERROR: corrupted file!')\n        resetConnector('uploadChosenFile')\n        return(NULL)\n    }\n\n    variablesEnv$tempData <- variablesEnv$tempData[,-1]\n\n  }\n\n observe({\n    if(!is.null(input$chosenVariables)){\n        chosenVariables <- input$chosenVariables\n        names <- (names(chosenVariables))\n        types <- unlist(chosenVariables$type)\n        variablesTypes <- unlist(chosenVariables$variablesTypes)\n\n        tmp <- variablesEnv$tempData\n        for(index in (1: length(variablesTypes))){\n            eval(parse(text = paste0('tmp[,index] <- as.', variablesTypes[index],'(tmp[,index])')))\n        }\n        data <- new(\"compData\", tmp, availableGemasInfo = variablesEnv$availableGemasInfo)\n        data@variablesTypes <- variablesTypes\n\n        for(index in 1:length(types)){\n            variables <- unlist(chosenVariables[index])\n            if(!is.null(variables)){\n                if(types[index] == \"comp\"){\n                    data@compositions[[names[index]]] <- variables\n                }\n                else if(types[index] == \"extern\"){\n                    data@externals[[names[index]]] <- variables\n                }\n                else if(types[index] == \"coord\"){\n                    data@coords[[names[index]]] <- variables\n                }\n                else{\n                    data@ids[[names[index]]] <- variables\n                }\n            }\n        }\n        if(variablesEnv$availableGemasInfo){\n            data@gemasInfo <- variablesEnv$tempGemasInfo\n        }\n\n        eval(parse(text = paste0(\"variablesEnv$dataList$\",variablesEnv$name ,\"<- data\")))\n        variablesEnv$uploadPath <- NULL\n\n        sendPopUpMessage('Chosen data was successfully uploaded!')\n        names <- as.list(names(variablesEnv$dataList))\n        createDataSelector(names)\n    }\n  })\n\n    # chosen data from the data selector\n    observe({\n        input$dataSelectorChosenData\n        if(!is.null(input$dataSelectorChosenData)){\n            if(input$dataSelectorChosenData != \"\"){\n                if(!is.null(variablesEnv$currentDataName)){\n                    eval(parse(text = paste0(\"variablesEnv$dataList$\",variablesEnv$currentDataName ,\"<-variablesEnv$currentData\")))\n                }\n\n                variablesEnv$currentDataName <- as.character(input$dataSelectorChosenData)\n                variablesEnv$currentData <- variablesEnv$dataList[as.character(input$dataSelectorChosenData)]\n                variablesEnv$currentData <- eval(parse(text = paste0(\"variablesEnv$currentData$\", as.character(input$dataSelectorChosenData))))\n                renderDataInformation(createJSObject())\n\n            }\n        }\n    })\n\n    # chosen package\n    observe({\n        input$chosenPackage\n        if(!is.null(input$chosenPackage)){\n            eval(parse(text = paste0(\"library(\", input$chosenPackage, \")\")))\n            eval(parse(text = paste0('availableDataInThePackage <- data(package = \"', input$chosenPackage, '\")$results[,3]')))\n            if(length(availableDataInThePackage) == 0){\n                sendPopUpMessage('Chosen package contains no data!')\n            }\n            else{\n                session$sendCustomMessage(type = 'availableDataInThePackage', message = availableDataInThePackage)\n                variablesEnv$availableGemasInfo <- FALSE\n            }\n        }\n    })\n\n    #chosen data from package\n    observe({\n        variablesEnv$name <- input$chosenData\n        if(!is.null(variablesEnv$name)){\n            eval(parse(text = paste0(\"data(\", variablesEnv$name, \")\")))\n            variablesEnv$tempData <- eval(parse(text = variablesEnv$name))\n            if(!is.null(variablesEnv$tempData)){\n                variablesEnv$uploadPath <- NULL\n                session$sendCustomMessage(type = 'createFileOptionDialog', message = variablesEnv$name)\n            }\n        }\n    })\n\n#######################################################################################################################################\n############################################################ EDIT DATA ################################################################\n#######################################################################################################################################\n########################################################## REMOVE #####################################################################\nobserve({\n    options <- input$removeColumn\n    if(!is.null(options)){\n        indexes <- unlist(options$indexes)\n        data <- variablesEnv$currentData\n        Data <- as.data.frame(data@.Data)\n        tmpNames <- names(data)\n        tmpNames <- tmpNames[- (indexes + 1)]\n        Data <- Data[-(indexes + 1)]\n        data@.Data <- Data\n        names(data) <- tmpNames\n        compositions <- data@compositions\n        tmpNames <- names(compositions)\n\n        if(length(tmpNames) > 0){\n            for(i in (1: length(tmpNames))){\n                comp <- eval(parse(text = paste0('compositions$', tmpNames[i])))\n                for(k in (1 : length(indexes))){\n                  indexesToDelete <- which(comp == indexes[k])\n                  if(length(indexesToDelete) > 0){\n                      comp <- comp[-indexesToDelete]\n                  }\n              }\n              \n              for(j in (1 :length(indexes))){\n                if(length(comp[comp >= indexes[j]]) > 0){\n                  comp[comp >= indexes[j]] <- comp[comp >= indexes[j]] - 1\n                }\n              }\n              if(length(comp) == 0){\n                comp <- c()\n              }\n              eval(parse(text = paste0('compositions$', tmpNames[i], ' <- comp')))\n            }\n            data@compositions <- compositions\n        }\n\n        externals <- data@externals\n        tmpNames <- names(externals)\n        if(length(tmpNames) > 0){\n          for(i in (1: length(tmpNames))){\n            ext <- eval(parse(text = paste0('externals$', tmpNames[i])))\n            for(k in (1 : length(indexes))){\n              indexesToDelete <- which(ext == indexes[k])\n              if(length(indexesToDelete) > 0){\n                ext <- ext[-indexesToDelete]\n              }\n            }\n            \n            for(j in (1 :length(indexes))){\n              if(length(ext[ext >= indexes[j]]) > 0){\n                ext[ext >= indexes[j]] <- ext[ext >= indexes[j]] - 1\n              }\n            }\n            if(length(ext) == 0){\n              ext <- c()\n            }\n            eval(parse(text = paste0('externals$', tmpNames[i], ' <- ext')))\n          }\n          data@externals <- externals\n        }\n\n        coords <- data@coords\n        tmpNames <- names(coords)\n        if(length(tmpNames) > 0){\n          for(i in (1: length(tmpNames))){\n            coord <- eval(parse(text = paste0('coords$', tmpNames[i])))\n            for(k in (1 : length(indexes))){\n              indexesToDelete <- which(coord == indexes[k])\n              if(length(indexesToDelete) > 0){\n                coord <- coord[-indexesToDelete]\n              }\n            }\n            \n            for(j in (1 :length(indexes))){\n              if(length(coord[coord >= indexes[j]]) > 0){\n                coord[coord >= indexes[j]] <- coord[coord >= indexes[j]] - 1\n              }\n            }\n            if(length(coord) == 0){\n              coord <- c()\n            }\n            eval(parse(text = paste0('coords$', tmpNames[i], ' <- coord')))\n          }\n          data@coords <- coords\n        }\n\n        ids <- data@ids\n        tmpNames <- names(ids)\n        if(length(tmpNames) > 0){\n          for(i in (1: length(tmpNames))){\n            id <- eval(parse(text = paste0('ids$', tmpNames[i])))\n            for(k in (1 : length(indexes))){\n              indexesToDelete <- which(id == indexes[k])\n              if(length(indexesToDelete) > 0){\n                id <- id[-indexesToDelete]\n              }\n            }\n            \n            for(j in (1 :length(indexes))){\n              if(length(id[id >= indexes[j]]) > 0){\n                id[id >= indexes[j]] <- id[id >= indexes[j]] - 1\n              }\n            }\n            if(length(id) == 0){\n              id <- c()\n            }\n            eval(parse(text = paste0('ids$', tmpNames[i], ' <- id')))\n          }\n          data@ids <- ids\n        }\n        \n        variablesEnv$currentData <- data\n        renderDataInformation(createJSObject())\n        sendPopUpMessage('Column(s) successfully removed!')\n        resetConnector('removeColumn')\n        setDataAndGroup(variablesEnv$currentDataName, options$group, options$subset)\n    }\n})\n\n############################################################ ADD ######################################################################\n    observe({\n        options <- input$addOrEditColumn\n        if(!is.null(options)){\n            data <- variablesEnv$currentData\n            Data <- as.data.frame(data@.Data)\n            names(Data) = names(data)\n            names <- unlist(options$names)\n            commands <- unlist(options$commands)\n            attach(data)\n\n\n            method = NULL\n            unit = NULL\n            extraction = NULL\n\n            gemasInfo <- data@gemasInfo\n            if(!is.null(gemasInfo) && length(gemasInfo) > 1){\n                method <- gemasInfo@method\n                index <- ceiling(0.6 * length(method))\n                method <- method[index]\n                unit <- gemasInfo@unit[index]\n\n            }\n\n            for(i in (1: length(commands))){\n                try <- tryCatch({eval(parse(text = commands[i]))}, error = function(cond){return(NULL)})\n                if(is.null(try)){\n                    sendPopUpMessage('Invalid command!');\n                    detach(data)\n                    return(NULL);\n                }else{\n                    eval(parse(text = paste0('Data[\"', names[i], '\"] <-', names[i])))\n                }\n            }\n\n            detach(data)\n            data@.Data <- Data\n            names(data) <- names(Data)\n            variablesEnv$currentData <- data\n\n            if(!is.null(options$typeOfVariables)){\n                if(options$typeOfVariables != 'allGroups'){\n                    variables <- getVariables(options$typeOfVariables, options$variables) - 1\n                    lengthData <- length(names(data)) - length(commands)\n                    newLength <- lengthData + (length(commands) -1)\n                    variables <- c(variables, (lengthData:newLength))\n\n                    variablesEnv$currentData <-  updateVariables(options$typeOfVariables, options$variables, variables)\n                }\n            }\n\n            renderDataInformation(createJSObject())\n            setDataAndGroup(variablesEnv$currentDataName, options$group, options$subset)\n            sendPopUpMessage(options$message)\n            resetConnector('addOrEditColumn')\n        }\n    })\n\n########################################################################################################################################\n################################################################### DATA MANIPULATION ##################################################\n########################################################################################################################################\n################################################################### IMPUTATION #########################################################\n############################################ impCoda ###################################################################################\n    observe({\n        options <- input$impCodaImp\n        if(!is.null(options)){\n            data <- as.data.frame(variablesEnv$currentData)\n            variablesEnv$currentVariableGroup <- (unlist(options$variablesGroup) + 1)\n            variablesEnv$currentSubset <- (unlist(options$subsetGroup) + 1)\n            if(length(variablesEnv$currentVariableGroup) != 0){\n                data <- data[variablesEnv$currentVariableGroup]\n            }\n\n            try <- tryCatch({eval(parse(text = paste0('tmp <- impCoda(x = data, ', 'maxit=', options$maxit, ', method=\"', options$method, '\")')))},\n                            error = function(cond){return(NULL)})\n            if(is.null(try)){\n                sendPopUpMessage(\"ERROR: too much NA's on one row!\")\n            }\n            else{\n                data <- variablesEnv$currentData\n                tmp <- tmp$xImp\n                data <- replaceOriginalDataWithImputation(data, tmp)\n\n                if(options$name != 0){\n                    options(options$name, data)\n                }else{\n                    variablesEnv$currentData <- data\n                }\n                renderDataInformation(createJSObject())\n                setDataAndGroup(variablesEnv$currentDataName, options$group, options$subset)\n                sendPopUpMessage('Imputation successfully done!')\n                resetConnector('impCoda')\n            }\n         }\n    })\n\n########################################### impKNNa ############################################\n    observe({\n        options <- input$impKNNaImp\n        if(!is.null(options)){\n            data <- as.data.frame(variablesEnv$currentData)\n            variablesEnv$currentVariableGroup <- (unlist(options$variablesGroup) +1)\n            if(length(variablesEnv$currentVariableGroup) != 0){\n                data <- data[variablesEnv$currentVariableGroup]\n            }\n\n            try <- tryCatch({eval(parse(text = paste0('tmp <- impKNNa(x = data, ', 'k=', options$k,')')))},\n                            error = function(cond){return(NULL)})\n            if(is.null(try)){\n                sendPopUpMessage(\"ERROR: too much NA's on one row!\")\n            }\n            else{\n                data <- variablesEnv$currentData\n                tmp <- tmp$xImp\n                data <- replaceOriginalDataWithImputation(data, tmp)\n\n                if(options$name != 0){\n                    addNewDataToDataList(options$name, data)\n                }else{\n                    variablesEnv$currentData <- data\n                }\n                renderDataInformation(createJSObject())\n                setDataAndGroup(variablesEnv$currentDataName, options$group, options$subset)\n                sendPopUpMessage('Imputation successfully done!')\n                resetConnector('impKNNa')\n            }\n         }\n    })\n\n########################################## kNN #################################################\n    observe({\n        options <- input$kNNImp\n        if(!is.null(options)){\n           data <- as.data.frame(variablesEnv$currentData)\n           variablesEnv$currentVariableGroup <- (unlist(options$variablesGroup) +1)\n            if(length(variablesEnv$currentVariableGroup) != 0){\n                data <- data[variablesEnv$currentVariableGroup]\n            }\n\n            try <- tryCatch({eval(parse(text = paste0('tmp <- kNN(data = data, ', 'k=', options$k, ')')))},\n                            error = function(cond){return(NULL)})\n\n            if(is.null(try)){\n                sendPopUpMessage(\"ERROR: too much NA's on one row!\")\n            }\n            else\n            {\n                tmp <- tmp[1:length(data)]\n\n                data <- variablesEnv$currentData\n                data <- replaceOriginalDataWithImputation(data, tmp)\n\n                if(options$name != 0){\n                    addNewDataToDataList(options$name, data)\n                }else{\n                    variablesEnv$currentData <- data\n                }\n\n                renderDataInformation(createJSObject())\n                setDataAndGroup(variablesEnv$currentDataName, options$group, options$subset)\n                sendPopUpMessage('Imputation successfully done!')\n                resetConnector('kNNImp')\n            }\n         }\n    })\n\n############################################ irmi ################################################\n    observe({\n        options <- input$irmiImp\n        if(!is.null(options)){\n            data <- as.data.frame(variablesEnv$currentData)\n            variablesEnv$currentVariableGroup <- (unlist(options$variablesGroup) +1)\n            if(length(variablesEnv$currentVariableGroup) != 0){\n                data <- data[variablesEnv$currentVariableGroup]\n            }\n\n            try <- tryCatch({eval(parse(text = paste0('tmp <- irmi(x = data)')))},\n                            error = function(cond){return(NULL)})\n\n            if(is.null(try)){\n                sendPopUpMessage(\"ERROR: too much NA's on one row!\")\n            }\n            else{\n                data <- variablesEnv$currentData\n                data <- replaceOriginalDataWithImputation(data, tmp)\n\n                if(options$name != 0){\n                    addNewDataToDataList(options$name, data)\n                }else{\n                    variablesEnv$currentData <- data\n                }\n                renderDataInformation(createJSObject())\n                setDataAndGroup(variablesEnv$currentDataName, options$group, options$subset)\n                sendPopUpMessage('Imputation successfully done!')\n                resetConnector('irmiImp')\n            }\n         }\n    })\n\n\n    replaceOriginalDataWithImputation <- function(data, imputation){\n        Data <- data@.Data\n        if(length(variablesEnv$currentVariableGroup) != 0){\n            Data[variablesEnv$currentVariableGroup] <- as.data.frame(imputation)\n            data@.Data <- Data\n        }\n        else{\n            Data <- tmp\n            data@.Data <- imputation\n        }\n        return(data)\n    }\n\n\n#######################################################################################################################################\n######################################################### DETECTION LIMIT #############################################################\n#######################################################################################################################################\n######################################################### impRZilr ####################################################################\n    observe({\n        options <- input$inpRZilr\n        if(!is.null(options)){\n            data <- as.data.frame(variablesEnv$currentData)\n            variablesEnv$currentVariableGroup <- (unlist(options$variablesGroup) + 1)\n            dl <- data@gemasInfo\n            dl <- dl@LDL\n            dl <- as.numeric(dl)\n            if(length(options$variablesGroup) != 0){\n                data <- data[variablesEnv$currentVariableGroup]\n                dl <- dl[variablesEnv$currentVariableGroup]\n            }\n\n            try <- tryCatch({eval(parse(text = paste0('tmp <- impRZilr(x = data, dl = dl, method = \"', options$method ,'\")')))},\n                            error = function(cond){return(NULL)})\n\n            if(is.null(try)){\n                sendPopUpMessage(\"ERROR occoured!\")\n            }else{\n                data <- variablesEnv$currentData\n                data <- replaceOriginalDataWithImputation(data, tmp$x)\n\n                if(options$name != 0){\n                    addNewDataToDataList(options$name, data)\n                }\n                else{\n                    variablesEnv$currentData <- data\n                }\n\n                renderDataInformation(createJSObject())\n                setDataAndGroup(variablesEnv$currentDataName, options$group, options$subset)\n                sendPopUpMessage('Imputation successfully done!')\n                resetConnector('impRZilr')\n            }\n        }\n    })\n\n########################################################## DL * factor #################################################################\n    observe({\n        options <- input$DLMultiplyByFactor\n        if(!is.null(options)){\n            data <- as.data.frame(variablesEnv$currentData)\n            variablesEnv$currentVariableGroup <- (unlist(options$variablesGroup) + 1)\n            constant <- options$constant\n            dl <- data@gemasInfo\n            dl <- dl@LDL\n            dl <- as.numeric(dl)\n            if(length(options$variablesGroup) != 0){\n                data <- data[variablesEnv$currentVariableGroup]\n                dl <- dl[variablesEnv$currentVariableGroup]\n            }\n            tmp <- c()\n            for(i in (1: length(dl))){\n                col <- data[i]\n                if(length(col[col < dl[i]]) > 0){\n                    col[col < dl[i]] <- eval(parse(text = paste(dl[i],'*',constant)))\n                }\n                tmp[i] <- col\n            }\n\n            data <- variablesEnv$currentData\n            data <- replaceOriginalDataWithImputation(data, tmp)\n\n            if(options$name != 0){\n                addNewDataToDataList(options$name, data)\n             }else{\n                variablesEnv$currentData <- data\n             }\n\n             renderDataInformation(createJSObject())\n             setDataAndGroup(variablesEnv$currentDataName, options$group, options$subset)\n             sendPopUpMessage('Imputation successfully done!')\n             resetConnector('DLMultiplyByFactor')\n        }\n    })\n\n#######################################################################################################################################\n######################################################### TRANSFORMATIONS #############################################################\n#######################################################################################################################################\n########################################################### addLR #####################################################################\n    observe({\n        options <- input$addLR\n        if(!is.null(options)){\n            data <- as.data.frame(variablesEnv$currentData)\n            variablesEnv$currentVariableGroup <- (as.numeric(unlist(options$variablesGroup)) + 1)\n            if(length(options$variablesGroup) != 0){\n                data <- data[variablesEnv$currentVariableGroup]\n            }\n\n            try <- tryCatch({eval(parse(text = paste0('tmp <- addLR(x = data, ivar = ', as.numeric(options$ivar), ')')))},\n                            error = function(cond){return(NULL)})\n\n            if(is.null(try)){\n                sendPopUpMessage(\"ERROR occoured!\")\n            }\n            else\n            {\n                tmp <- tmp$x.alr\n                oldNames <- names(tmp)\n                newNames <- c()\n                for(i in (1:length(oldNames))){\n                    newNames[i] <- paste0(oldNames[i], '_', options$ivarName)\n                }\n                tmp <- as.data.frame(tmp)\n                names(tmp) <- newNames\n                data <- as.data.frame(variablesEnv$currentData)\n                eval(parse(text = paste0('data@transformations$', as.character(options$name), '<- as.data.frame(tmp)')))\n\n                variablesEnv$currentData <- data\n                renderDataInformation(createJSObject())\n                sendPopUpMessage('Transformation successfully done!')\n                resetConnector('addLR')\n                setDataAndGroup(variablesEnv$currentDataName, options$name, options$subset)\n            }\n        }\n    })\n\n########################################################## cenLR ######################################################################\n    observe({\n        options <- input$cenLR\n        if(!is.null(options)){\n            data <- as.data.frame(variablesEnv$currentData)\n            variablesEnv$currentVariableGroup <- (as.numeric(unlist(options$variablesGroup)) + 1)\n            if(length(options$variablesGroup) != 0){\n                data <- data[variablesEnv$currentVariableGroup]\n            }\n\n            try <- tryCatch({eval(parse(text = 'tmp <- cenLR(x = data)'))}, error = function(cond){return(NULL)})\n\n            if(is.null(try)){\n                sendPopUpMessage(\"ERROR occoured!\")\n            }\n            else\n            {\n                tmp <- tmp$x.clr\n                oldNames <- names(tmp)\n                newNames <- c()\n                for(i in (1:length(oldNames))){\n                    newNames[i] <- paste0(oldNames[i],'_clr')\n                }\n\n                names(tmp) <- newNames\n                data <- as.data.frame(variablesEnv$currentData)\n                eval(parse(text = paste0('data@transformations$', as.character(options$name), '<- as.data.frame(tmp)')))\n\n                variablesEnv$currentData <- data\n                renderDataInformation(createJSObject())\n                sendPopUpMessage('Transformation successfully done!')\n                resetConnector('cenLR')\n                setDataAndGroup(variablesEnv$currentDataName, options$name, options$subset)\n            }\n\n        }\n    })\n\n########################################################## isomLR ######################################################################\n    observe({\n        options <- input$isomLR\n        if(!is.null(options)){\n            data <- as.data.frame(variablesEnv$currentData)\n            variablesEnv$currentVariableGroup <- (as.numeric(unlist(options$variablesGroup)) + 1)\n            if(length(options$variablesGroup) != 0){\n                data <- data[variablesEnv$currentVariableGroup]\n            }\n\n            try <- tryCatch({eval(parse(text = 'tmp <- isomLR(x = data)'))}, error = function(cond){return(NULL)})\n            if(is.null(try)){\n                sendPopUpMessage(\"ERROR occoured!\")\n            }\n            else\n            {\n                tmp <- as.data.frame(tmp)\n                oldNames <- names(tmp)\n                newNames <- c()\n                for(i in (1:length(oldNames))){\n                    newNames[i] <- paste0('ilr_', i)\n                }\n\n                names(tmp) <- newNames\n                data <- as.data.frame(variablesEnv$currentData)\n                eval(parse(text = paste0('data@transformations$', as.character(options$name), '<- as.data.frame(tmp)')))\n\n                variablesEnv$currentData <- data\n                renderDataInformation(createJSObject())\n                sendPopUpMessage('Transformation successfully done!')\n                resetConnector('isomLR')\n                setDataAndGroup(variablesEnv$currentDataName, options$name, options$subset)\n            }\n\n\n\n        }\n    })\n############################################################ command #####################################################################\n    observe({\n        options <- input$transformationCommand\n        if(!is.null(options)){\n            data <- as.data.frame(variablesEnv$currentData)\n            variablesEnv$currentVariableGroup <- (as.numeric(unlist(options$variablesGroup)) + 1)\n            if(length(options$variablesGroup) != 0){\n                data <- data[variablesEnv$currentVariableGroup]\n            }\n\n            try <- tryCatch({eval(parse(text = paste0('tmp <-', options$command ,'(data)')))}, error = function(cond){return(NULL)})\n            if(is.null(try)){\n                sendPopUpMessage(\"ERROR: chosen method does not exist or can\\'t be applied on chosen data!\")\n            }\n            else{\n                oldNames <- names(tmp)\n                newNames <- c()\n                for(i in (1:length(oldNames))){\n                    newNames[i] <- paste0(oldNames[i], '_', options$command)\n                }\n                names(tmp) <- newNames\n                data <- as.data.frame(variablesEnv$currentData)\n                eval(parse(text = paste0('data@transformations$', as.character(options$name), '<- as.data.frame(tmp)')))\n\n                variablesEnv$currentData <- data\n                renderDataInformation(createJSObject())\n                sendPopUpMessage('Transformation successfully done!')\n                resetConnector('log')\n                setDataAndGroup(variablesEnv$currentDataName, options$name, options$subset)\n            }\n        }\n    })\n\n#######################################################################################################################################\n################################################### DEFINE NEW VARIABLES GROUP ########################################################\n#######################################################################################################################################\n\n    observe({\n        options <- input$newDefinedVariablesGroups\n        if(!is.null(options)){\n            data <- variablesEnv$currentData\n            groupNames <- names(options)\n            groupNames <- groupNames[-length(groupNames)]\n            if(options$type == \"transformations\"){\n                nrow = options[1]\n                eval(parse(text = paste0('nrow <- nrow$', groupNames[1])))\n                nrow <- nrow[as.character((names(nrow)[1]))]\n                eval(parse(text = paste0('nrow <- nrow$', names(nrow))))\n                nrow[unlist(lapply(nrow, is.null))] <- NA\n                nrow <- length(unlist(nrow))\n\n                for(i in (1: length(groupNames))){\n                    tmpOptions <- options[i]\n                    eval(parse(text = paste0('tmpOptions <- tmpOptions$', groupNames[i])))\n                    names <- names(tmpOptions)\n                    tmp <- matrix(0, ncol = length(names), nrow = nrow)\n                    tmp <- as.data.frame(tmp)\n                    names(tmp) <- names\n\n                    for(j in (1:length(names))){\n                        currentTmpOptions <- tmpOptions[as.character(names[j])]\n                        eval(parse(text = paste0('currentTmpOptions <- currentTmpOptions$', names(currentTmpOptions))))\n                        currentTmpOptions[unlist(lapply(currentTmpOptions, is.null))] <- NA\n                        eval(parse(text = paste0('tmp[', j, '] <-', as.vector(unlist(currentTmpOptions)))))\n                    }\n                    data@transformations[[as.character(groupNames[i])]] <- tmp\n                }\n            }else{\n                for(i in (1:length(groupNames))){\n                    variables <- unlist(options[i])\n                    if(options$type == \"comp\"){\n                        data@compositions[[groupNames[i]]] <- variables\n                    }\n                    else if(options$type == \"extern\"){\n                        data@externals[[groupNames[i]]] <- variables\n                    }\n                    else if(options$type == \"coord\"){\n                        data@coords[[groupNames[i]]] <- variables\n                    }\n                    else{\n                        data@ids[[groupNames[i]]] <- variables\n                    }\n                }\n            }\n            variablesEnv$currentData <- data\n            sendPopUpMessage('New data variables groups were successfully created!')\n            resetConnector('newDefinedVariablesGroups')\n        }\n    })\n\n#######################################################################################################################################\n################################################# DEFINE NEW OBSERVATIONS GROUP #######################################################\n#######################################################################################################################################\n################################################################ COMMAND ##############################################################\n    observe({\n        options <- input$defineObservationsCommand\n        if(!is.null(options)){\n            commands <- as.vector(unlist(options$commands))\n            data <- variablesEnv$currentData\n            attach(data)\n            indexes <- c()\n            for(i in (1 : length(commands))){\n                try <- tryCatch({indexes <- c(indexes, eval(parse(text = paste0('which(', commands[i], ')'))))}, error = function(cond){return(NULL)})\n                if(is.null(try)){\n                    sendPopUpMessage('Invalid command!');\n                    detach(data)\n                    return(NULL);\n                }\n            }\n            indexes <- unique(indexes)\n            indexes <- sort(indexes) - 1\n\n            data@subsets[[options$name]] <- indexes\n\n            detach(data)\n            variablesEnv$currentData <- data\n\n            sendPopUpMessage('Observation group was successfully defnined!')\n            renderDataInformation(createJSObject())\n            setDataAndGroup(variablesEnv$currentDataName, options$group, options$name)\n            resetConnector('defineObservationsCommand')\n        }\n    })\n\n################################################################ FACTOR ##############################################################\n\n    observe({\n        options <- input$defineObservationsFactor\n        if(!is.null(options)){\n           data <- variablesEnv$currentData\n            subsetNames <- names(options)\n            for(i in (1: length(subsetNames))){\n                indexes <- unlist(options[i])\n                data@subsets[[subsetNames[i]]] <- indexes\n            }\n            variablesEnv$currentData <- data\n\n            sendPopUpMessage('Observation group(s) was successfully defnined!')\n            resetConnector('defineObservationsFactor')\n        }\n    })\n\n########################################################################################################################################\n################################################################### Statistical Methods ################################################\n########################################################################################################################################\n############################################################## PCA #####################################################################\n    #ggplot() + geom_point(data =(p$scores), aes(x=p$scores[,1],y=p$scores[,2] )) + geom_line(data = load2, aes(x = Factor1, y = Factor2, color = \"red\"))\n    #load=as.data.frame(unclass(p$loadings))\n    \n    round_df <- function(x, digits) {\n      # round all numeric variables\n      # x: data frame \n      # digits: number of digits to round\n      numeric_columns <- sapply(x, class) == 'numeric'\n      x[numeric_columns] <-  round(x[numeric_columns], digits)\n      x\n    }\n    \n    \n    observe({\n      \n      options <- input$pca.in\n      if(!is.null(options)){\n        \n        \n        try <- tryCatch({\n          dataAll <- variablesEnv$currentData\n          \n          \n          data <- dataAll[1]\n          data <- data[-c(1)]\n          for ( i in 1:(length(names(dataAll))) ) {\n            if(length(which(names(dataAll)==options$variablesdName[i]))>0){\n              data[options$variablesdName[[i]]] <- (dataAll[which(names(dataAll)==options$variablesdName[i])])\n            }\n          }\n          if(options$type == 'compositions'){\n            temdata <- data\n          }\n          else if(options$log){\n              temdata <- log(data)\n              temdata <- rapply( temdata, f=function(x) ifelse(is.infinite(x),0,x), how=\"replace\" )\n              temdata <- as.data.frame(temdata)\n            }\n            else{\n              temdata <- data\n            }\n          \n        }, error = function(cond){\n          sendPopUpMessage(paste0('Error in data-input or transformation:  ',as.character(cond$message)))\n          return(NULL)})\n        \n        if(!is.null(try)){\n          try <- tryCatch({\n            if(options$type == 'compositions'){\n              if(options$method == 'robust'){\n                tmp <- pcaCoDa(temdata, method = 'robust')\n                \n              }\n              else if (options$method == 'standard'){\n                tmp <- pcaCoDa(temdata, method = 'standard')\n              }\n              else{\n                sendPopUpMessage(paste0('ERROR: method \"', options$method, '\" is not supported' ))\n              }\n              # needed for autoplot\n              tmp$princompOutputClr$scale <- NULL\n              tmp$princompOutputClr$center <- NULL\n              \n              #add pc's to data ==> needed for nearPoints and brushedPoints function\n              total <- temdata[1]\n              total <- total[-c(1)]\n              total<- merge(total,as.data.frame(tmp$princompOutputClr$scores), by=\"row.names\")\n              total <- transform(total, Row.names = as.numeric(Row.names))\n              \n            }\n            else if(options$type == 'externals'){\n              \n              if(options$method == 'robust'){\n               tmp <- prcomp(temdata,scale=options$scale, covmat =covPCAproj(temdata)$cov )\n                \n              }\n              else if (options$method == 'standard'){\n                tmp <- prcomp(temdata,scale=options$scale)\n              }\n              else{\n                sendPopUpMessage(paste0('ERROR: method \"', options$method, '\" is not supported' ))\n              }\n              #add rownames to pc's \n              total <- temdata[1]\n              total <- total[-c(1)]\n              total<- merge(total,as.data.frame(tmp$x), by=\"row.names\")\n              total <- transform(total, Row.names = as.numeric(Row.names))\n              \n            }\n            else{\n              sendPopUpMessage(paste0('ERROR: type \"', options$type, '\" is not supported' ))\n            }\n          }, error = function(cond){\n            sendPopUpMessage(paste0('Error applying pca-function:  ',as.character(cond$message)))\n            return(NULL)})\n        }\n        \n        \n        \n        if(is.null(try)){\n          sendPopUpMessage(\"ERROR: chosen method does not exist or can\\'t be applied on chosen data!\")\n        }\n        else{\n          try <- tryCatch({\n          \n            if(options$type == 'compositions'){\n              output$pca.BiPlot <- renderPlot({\n                #ggbiplot(tmp$princompOutputClr, scale = 0, labels.size = 3)\n                biplot <- autoplot(tmp$princompOutputClr, data = total)\n                eval(parse(text = paste0('biplot <- biplot + aes( Comp.', options$x ,', Comp.',options$y,')')))\n                biplot\n              })\n              \n              output$pca.BiPlotNoInteraction <- renderPlot({\n                biplot(tmp$princompOutputClr, choices = c(as.numeric(options$x),as.numeric(options$y)))\n              })\n              \n              output$pca.ScreePlot <- renderPlot({\n                screeplot(tmp$princompOutputClr, type = 'l')\n                \n              })\n              \n              output$pca.Summary <- renderPrint({\n                  print(summary(tmp$princompOutputClr))\n              })\n              \n              output$pca.Loadings <- renderDataTable({\n                if(length(tmp$loadings[1,])>8){\n                  loadings <- round_df(tmp$loadings[,c(1:8)],3)\n                }\n                else{\n                  loadings <- round_df(tmp$loadings,3)\n                }\n                loadings <- as.data.frame(loadings)\n                temLoadData <- loadings[1]\n                temLoadData <- temLoadData[-c(1)]\n                merge(temLoadData,loadings, by=\"row.names\")\n              })\n              \n              \n            }\n            else{\n              output$pca.BiPlot <- renderPlot({\n                #ggbiplot(tmp, labels =  rownames(tmp),scale = 0)\n                biplot <- autoplot(tmp, data = total)\n                eval(parse(text = paste0('biplot <- biplot + aes( PC', options$x ,', PC',options$y,')')))\n                biplot\n              })\n              \n              output$pca.BiPlotNoInteraction <- renderPlot({\n                biplot(tmp, choices = c(as.numeric(options$x),as.numeric(options$y)))\n              })\n              \n              output$pca.ScreePlot <- renderPlot({\n                screeplot(tmp, type = 'l')\n              })\n              \n              output$pca.Summary <- renderPrint({\n                print(summary(tmp))\n              })\n              \n              output$pca.Loadings <- renderDataTable({\n                if(length(tmp$rotation[1,])>8){\n                  loadings <- round_df(tmp$rotation[,c(1:8)],3)\n                }\n                else{\n                  loadings <- round_df(tmp$rotation,3)\n                }\n                loadings <- as.data.frame(loadings)\n                temLoadData <- loadings[1]\n                temLoadData <- temLoadData[-c(1)]\n                merge(temLoadData,loadings, by=\"row.names\")\n              })\n            }\n          \n            output$pca.click_info <- renderDataTable({\n              if(options$type == 'compositions'){\n                tmpInFoTable <- round_df(nearPoints(total, input$pca.Plot_click,paste0('Comp.', options$x),paste0('Comp.', options$y)),3)\n              }\n              else{\n                tmpInFoTable <- round_df(nearPoints(total, input$pca.Plot_click,paste0('PC', options$x),paste0('PC', options$y)),3)\n              }\n              if(length(tmpInFoTable[1,])>9){\n                tmpInFoTable[,c(1:9)]\n              }\n              else{\n                tmpInFoTable\n              }\n              \n            },options=list(\n              paging = FALSE,\n              searching = FALSE))\n            \n            \n            output$pca.brush_info <- renderDataTable({\n              tmpBrushTable <- round_df(filteredData(),3)\n              if(length(tmpBrushTable[1,])>9){\n                tmpBrushTable[,c(1:9)]\n              }\n              else{\n                tmpBrushTable\n              }\n            })\n            \n            \n            output$pcaDownloadScors <- downloadHandler(\n              filename = function() { \n                paste('score', '.csv', sep='') \n              },\n              content = function(file) {\n                if(options$type == 'compositions'){\n                  write.csv(tmp$scores, file,row.names = FALSE)\n                }\n                else{\n                  write.csv(tmp$x, file,row.names = FALSE)\n                }\n                \n              }\n            )\n            \n            output$pcaDownloadLoadings <- downloadHandler(\n              filename = function() { \n                paste('loadings', '.csv', sep='') \n              },\n              content = function(file) {\n                if(options$type == 'compositions'){\n                  write.csv(tmp$loadings, file,row.names = FALSE)\n                }\n                else{\n                  write.csv(tmp$rotation, file,row.names = FALSE)\n                }\n                \n              }\n            )\n            \n            output$pcaDownloadFilteredData <- downloadHandler(\n              filename = function() { \n                paste('filteredData', '.csv', sep='') \n              },\n              content = function(file) {\n                write.csv(filteredData(), file,row.names = FALSE)\n              }\n            )\n            \n            \n            filteredData <- reactive({\n              if(options$type == 'compositions'){\n                brushedPoints(total, input$pca.Plot_brush,paste0('Comp.', options$x),paste0('Comp.', options$y))\n              }\n              else{\n                brushedPoints(total, input$pca.Plot_brush,paste0('PC', options$x),paste0('PC', options$y))\n              }\n              \n            })\n            \n          }, error = function(cond){\n            \n            sendPopUpMessage(paste0('Error while creating plots:  ',as.character(cond$message)))\n            return(NULL)})\n        }\n        \n      }\n      \n    })\n\n    \n    ############################################################## Factor Analysis #####################################################################\n\n    #plotten von factanal\n    #http://rpubs.com/sinhrks/plot_pca\n    \n    observe({\n      \n      options <- input$pfa.in\n      if(!is.null(options)){\n        try <- tryCatch({\n          dataAll <- variablesEnv$currentData\n          \n          variablesEnv$currentVariableGroup <- (as.numeric(unlist(options$groupData)) + 1)\n          if(length(options$groupData) != 0){\n            dataAll <- data[variablesEnv$currentVariableGroup]\n          }\n          data <- dataAll[1]\n          data <- data[-c(1)]\n          for ( i in 1:(length(names(dataAll))) ) {\n            if(length(which(names(dataAll)==options$variablesdName[i]))>0){\n              data[options$variablesdName[[i]]] <- (dataAll[which(names(dataAll)==options$variablesdName[i])])\n            }\n          }\n          \n          if(options$type == 'compositions'){\n              temdata <- data\n          }\n          else{\n            if(options$log){\n              temdata <- log(data)\n              temdata <- rapply( temdata, f=function(x) ifelse(is.infinite(x),0,x), how=\"replace\" )\n              temdata <- as.data.frame(temdata)\n            }\n            else{\n              temdata <- data\n            }\n          }\n        }, error = function(cond){\n          sendPopUpMessage(paste0('Error in data-input or transformation:  ',as.character(cond$message)))\n          return(NULL)})\n        \n        if(!is.null(try)){\n          try <- tryCatch({\n            if(options$func == 'pfa'){\n              if(options$type == 'compositions'){\n                \n                if(options$pfaRobust == 'robust'){\n                  x.mcd=covMcd(temdata,cor=TRUE) \n                  x.rsc=scale(temdata,x.mcd$cent,sqrt(diag(x.mcd$cov))) \n                  #res1 <- pfa(x, factors=1, covmat=\"covMcd\")\n                  tmp=StatDA::pfa(x.rsc,factors=as.numeric(options$numberOfFactorsTextField),covmat=x.mcd,scores=options$score,rotation=options$rotation) \n                  \n                }\n                else{\n                  tmp=StatDA::pfa(scale(temdata),factors=as.numeric(options$numberOfFactorsTextField),scores=options$score,rotation=options$rotation) \n                }\n              }\n              else{\n                if(options$pfaRobust == 'robust'){\n                  x.mcd=covMcd(temdata,cor=TRUE) \n                  x.rsc=scale(temdata,x.mcd$cent,sqrt(diag(x.mcd$cov))) \n                  #res1 <- pfa(x, factors=1, covmat=\"covMcd\")\n                  tmp=robCompositions::pfa(x.rsc,factors=as.numeric(options$numberOfFactorsTextField),covmat=x.mcd,scores=options$score,rotation=options$rotation) \n                  \n                }\n                else{\n                  tmp=robCompositions::pfa(scale(temdata),factors=as.numeric(options$numberOfFactorsTextField),scores=options$score,rotation=options$rotation) \n                }\n              }\n              \n            }\n            else if(options$func == 'factanal'){\n                \n                tmp=factanal(scale(temdata),factors=as.numeric(options$numberOfFactorsTextField),scores=options$score,rotation=options$rotation)\n            }\n            else{\n              sendPopUpMessage(paste0('ERROR: function \"', options$func, '\" is not supported' ))\n            }\n            #add rownames to factors \n            total <- temdata[1]\n            total <- total[-c(1)]\n            total <- merge(total,as.data.frame(tmp$scores), by=\"row.names\")\n            total <- transform(total, Row.names = as.numeric(Row.names))\n            \n          }, error = function(cond){\n            sendPopUpMessage(paste0('Error applying function ',options$func ,':  ',as.character(cond$message)))\n            return(NULL)})\n        }\n        \n        if(!is.null(try)){\n          try <- tryCatch({\n          output$pfa.BiPlot <- renderPlot({\n            biplot <- autoplot(tmp, data = temdata)\n            eval(parse(text = paste0('biplot <- biplot + aes( Factor', options$x ,', Factor',options$y,')')))\n            biplot\n          })\n          \n          output$pfa.BiPlotNoInteraction <- renderPlot({\n            biplot(tmp$scores, tmp$loadings[,c(as.numeric(options$x),as.numeric(options$y))], xlab=paste('Factor',options$x),  ylab=paste('Factor',options$y))\n          })\n          \n          output$pfa.Loadplot <- renderPlot({\n            loadplot(tmp,crit=0.3) \n          })\n          \n          output$pfa.Loadings <- renderPrint({\n            print(tmp)\n            \n          })\n          \n          \n          output$pfa.click_info <- renderDataTable({\n            tmpInFoTable <- round_df(nearPoints(total, input$pfa.Plot_click,paste0('Factor', options$x),paste0('Factor', options$y)),3)\n            if(length(tmpInFoTable[1,])>9){\n              tmpInFoTable[,c(1:9)]\n            }\n            else{\n              tmpInFoTable\n            }\n            },options=list(\n            paging = FALSE,\n            searching = FALSE))\n          \n          \n          output$pfa.brush_info <- renderDataTable({\n            tmpBrushTable <- round_df(filteredData(),3)\n            if(length(tmpBrushTable[1,])>9){\n              tmpBrushTable[,c(1:9)]\n            }\n            else{\n              tmpBrushTable\n            }\n          })\n          \n          \n          output$downloadScors <- downloadHandler(\n            filename = function() { \n              paste('score', '.csv', sep='') \n            },\n            content = function(file) {\n              write.csv(tmp$scores, file,row.names = FALSE)\n            }\n          )\n          \n          output$downloadFilteredData <- downloadHandler(\n            filename = function() { \n              paste('filteredData', '.csv', sep='') \n            },\n            content = function(file) {\n              write.csv(filteredData(), file,row.names = FALSE)\n            }\n          )\n          \n          output$pfaDownloadLoadings <- downloadHandler(\n            filename = function() { \n              paste('loadings', '.csv', sep='') \n            },\n            content = function(file) {\n                write.csv(tmp$loadings, file,row.names = FALSE)\n            }\n          )\n          \n          filteredData <- reactive({\n            brushedPoints(total, input$pfa.Plot_brush,paste0('Factor', options$x),paste0('Factor', options$y))\n          })\n        \n          }, error = function(cond){\n\n            sendPopUpMessage(paste0('Error while creating plots:  ',as.character(cond$message)))\n            return(NULL)})\n        }\n\n      }\n      \n    })\n    \n    \n    \n    \n    ############################################################## Discriminant Analysis #####################################################################\n    #LdaClassic, Linda, QdaClassic, QdaCov \n    #\n    \n    #http://www.statistik.tuwien.ac.at/StatDA/R-scripts/\n    \n    \n    \n    observe({\n      \n      options <- input$da.in\n      if(!is.null(options)){\n        \n        \n        try <- tryCatch({\n        dataAll <- variablesEnv$currentData\n        \n\n        temdata <- dataAll[which(names(dataAll)==options$groupingVariable)]\n        \n        \n        for ( i in 1:(length(names(dataAll))) ) {\n          if(length(which(names(dataAll)==options$variablesdName[i]))>0){\n            if((options$type == 'externals') && (options$variablesdNameLogTransf[i] == TRUE)) {\n              temdata[options$variablesdName[[i]]] <- log((dataAll[which(names(dataAll)==options$variablesdName[i])]))\n            }\n            else{\n              temdata[options$variablesdName[[i]]] <- (dataAll[which(names(dataAll)==options$variablesdName[i])])\n              \n            }\n          }\n        }\n        temdata[,-1] <- sapply(temdata[,-1], as.numeric)\n        \n        total <- temdata[1]\n        total <- total[-c(1)]\n        \n        }, error = function(cond){\n          sendPopUpMessage(paste0('Error in data-input or transformation:  ',as.character(cond$message)))\n          return(NULL)})\n        \n        \n        if(!is.null(try)){\n          try <- tryCatch({\n        total['group'] <- as.factor(temdata[,1])\n        \n        \n        if(options$func == 'daFisher'){\n          if(length(levels(factor(total[,1])))<=2){\n            sendPopUpMessage('ERROR: Grouping Variable has not enough factors daFischer (at least 3)!')\n            return(NULL)\n          }\n          if(options$type == 'compositions'){\n            if(options$robust == 'robust'){\n              tmp <- daFisher(temdata[,-1],grp=temdata[,1],method=\"robust\",coda=TRUE)\n            }\n            else{\n              tmp <- daFisher(temdata[,-1],grp=temdata[,1],method=\"classical\",coda=TRUE)\n            }\n          }\n          else{\n            if(options$robust == 'robust'){\n              tmp <- daFisher(temdata[,-1],grp=temdata[,1],method=\"robust\",coda=FALSE)\n            }\n            else{\n              tmp <- daFisher(temdata[,-1],grp=temdata[,1],method=\"classical\",coda=FALSE)\n            }\n          }\n          total['predicted'] <- predict(tmp)\n          total<- merge(total,as.data.frame(tmp$scores), by=\"row.names\")\n        }\n        \n        else if(options$func == 'LDA'){\n          if(options$type == 'compositions'){\n            X <- isomLR(temdata[,-1])\n            if(options$robust == 'robust'){\n              tmp <- Linda(X,temdata[,1],alpha=0.75)\n            }\n            else{\n              tmp <- LdaClassic(X,temdata[,1])\n            }\n          }\n          else{\n            if(options$robust == 'robust'){\n              tmp <- Linda(temdata[,-1],temdata[,1],alpha=0.75)\n            }\n            else{\n              tmp <- LdaClassic(temdata[,-1],temdata[,1])\n            }\n          }\n          total['predicted'] <- as.numeric(predict(tmp)@classification)\n        }\n        \n        else if(options$func == 'QDA'){\n          if(options$type == 'compositions'){\n            X <- isomLR(temdata[,-1])\n            if(options$robust == 'robust'){\n              tmp <- QdaCov(X,temdata[,1])\n            }\n            else{\n              tmp <- QdaClassic(X,temdata[,1])\n            }\n          }\n          else{\n            if(options$robust == 'robust'){\n              tmp <- QdaCov(temdata[,-1],temdata[,1])\n            }\n            else{\n              tmp <- QdaClassic(temdata[,-1],temdata[,1])\n            }\n          }\n          total['predicted'] <- as.numeric(predict(tmp)@classification)\n        }\n        \n        else{\n          sendPopUpMessage(paste0('ERROR: function \"', options$func, '\" is not supported' ))\n        }\n        \n          }, error = function(cond){\n            sendPopUpMessage(paste0('Error applying function ',options$func ,':  ',as.character(cond$message)))\n            return(NULL)})\n        }\n        \n        \n        \n        if(!is.null(try)){\n          try <- tryCatch({\n        \n        output$da.Plot <- renderPlot({\n          if(options$func == 'daFisher'){\n            eval(parse(text = paste0('ggplot(data = total, aes( V', options$x ,',V',options$y,')) + geom_point(colour = as.numeric(total$group),shape = total$predicted)')))\n            #ggplot(data = total, aes(V1 ,V2)) + geom_point(shape = total$group)\n          }\n        })\n        \n        \n        #renderPrint\n        output$da.click_info <- renderDataTable({\n          if(options$func == 'daFisher'){\n            nearPoints(total, input$da.Plot_click)\n          }\n        },options=list(\n          paging = FALSE,\n          searching = FALSE))\n        \n        #renderPrint\n        output$da.brush_info <- renderDataTable({\n          if(options$func == 'daFisher'){\n            brushedPoints(total, input$da.Plot_brush) \n          }\n        })\n        \n        output$da.print <- renderPrint({\n          print(tmp)\n        })\n        \n        \n        output$daDownloadScors <- downloadHandler(\n          filename = function() { \n            paste('scores', '.csv', sep='') \n          },\n          content = function(file) {\n              write.csv(tmp$scores, file,row.names = FALSE)\n            \n            \n          }\n        )\n        \n        output$daDownloadLoadings <- downloadHandler(\n          filename = function() { \n            paste('loadings', '.csv', sep='') \n          },\n          content = function(file) {\n            write.csv(tmp$loadings, file,row.names = FALSE)\n            \n          }\n        )\n        \n        output$daDownloadPredict <- downloadHandler(\n          filename = function() { \n            paste('predicted', '.csv', sep='') \n          },\n          content = function(file) {\n            write.csv(total$predicted , file,row.names = FALSE)\n          }\n        )\n          }, error = function(cond){\n            \n            sendPopUpMessage(paste0('Error while creating plots:  ',as.character(cond$message)))\n            return(NULL)})\n        }\n        \n        \n      }\n      \n    })  \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    ############################################################## ClusterAnalysis #####################################################################\n    \n    observe({\n      \n      options <- input$clust.in\n      if(!is.null(options)){\n        \n        dataAll <- variablesEnv$currentData\n        \n        try <- tryCatch({\n          data <- dataAll[1]\n          data <- data[-c(1)]\n          for ( i in 1:(length(names(dataAll))) ) {\n            if(length(which(names(dataAll)==options$variablesdName[i]))>0){\n              data[options$variablesdName[[i]]] <- (dataAll[which(names(dataAll)==options$variablesdName[i])])\n            }\n          }\n          \n          if(options$type == 'compositions'){\n            if(options$ilr){\n              temdata <- isomLR(data)\n              temdata <- as.data.frame(temdata)\n            }\n            else{\n              temdata <- data\n            }\n          }\n          else{ \n            if(options$log){\n              temdata <- log(data)\n              temdata <- rapply( unclass(temdata), f=function(x) ifelse(is.infinite(x),0,x), how=\"replace\" )\n              temdata <- as.data.frame(temdata)\n            }\n            else{\n              temdata <- data\n            }\n            if(options$scale){\n              temdata <- scale((temdata))\n              temdata <- as.data.frame(temdata)\n            }\n          }\n          tableData <- data[1]\n          tableData <- tableData[-c(1)]\n          tableData['Row.Names'] <- row.names(data)\n          tableData[options$x] <- dataAll[which(names(dataAll)==options$x)]\n          tableData[options$y] <- dataAll[which(names(dataAll)==options$y)]\n\n        }, error = function(cond){\n          sendPopUpMessage(paste0('Error in data-input or transformation:  ',as.character(cond$message)))\n          return(NULL)})\n        \n\n        if(!is.null(try)){\n          try <- tryCatch({\n            if(options$func == 'HClust'){\n              tmpclust <- hclust(dist(temdata), method = options$method)\n              clustdata <- cutree(tmpclust,options$numberOfClusters)\n              \n              tableData['Classification.HClust']<- clustdata\n              \n              output$clust.Plot <- renderPlot({\n                \n                eval(parse(text = paste0('ggplot((tableData), aes( ', options$x ,',',options$y,')) + geom_point(colour = clustdata)')))\n              })\n              \n              output$clust.Dendrogram <- renderPlot({\n                plot(tmpclust)\n              })\n    \n            }\n            else if(options$func == 'Kmeans'){\n              \n              tmpclust <- kmeans(temdata,options$numberOfClusters)\n              tableData['Classification.Kmeans']<-tmpclust$cluster\n              \n              \n              output$clust.Plot <- renderPlot({\n                eval(parse(text = paste0('ggplot((tableData), aes( ', options$x ,',',options$y,')) + geom_point(colour = tmpclust$cluster)')))\n                #ggplot((as.data.frame(olives_scale)), aes(palmitoleic,palmitic)) + geom_point(aes(colour = map(tmpclust$cluster))) +     scale_colour_gradientn(colours=rainbow(options$numberOfClusters))\n              })\n              \n            }\n            else if(options$func == 'MClust'){\n              \n              tmpclust <- Mclust(temdata,1:options$numberOfClusters)\n              tmpclust_Dr = MclustDR(tmpclust)\n              \n              tableData['Classification.MClust']<-map(tmpclust$z)\n              \n              output$clust.Plot <- renderPlot({\n              eval(parse(text = paste0('ggplot((tableData), aes( ', options$x ,',',options$y,')) + geom_point(colour = tmpclust_Dr$class)')))\n              #ggplot((as.data.frame(olives_scale)), aes(palmitoleic,palmitic)) + geom_point(aes(colour = map(tmpclust$z))) +     scale_colour_gradientn(colours=rainbow(options$numberOfClusters))\n              })\n              \n              output$clust.BicPlot <- renderPlot({\n                plot(tmpclust$BIC)\n              })\n              \n              output$clust.OptimalCluster <- renderPrint({\n                print(summary(tmpclust$BIC))\n                \n              })\n              \n              output$clust.ClusterVector <- renderPrint({\n                print(summary(tmpclust_Dr))\n                \n              })\n              \n            }\n            else{\n              sendPopUpMessage(paste0('ERROR: variant \"', options$variant, '\" is not supported' ))\n            }\n          }, error = function(cond){\n            sendPopUpMessage(paste0('Error applying function ',options$func ,':  ',as.character(cond$message)))\n            return(NULL)})\n        }\n        \n        \n\n        output$clust.click_info <- renderDataTable({\n          nearPoints(tableData, input$clust.Plot_click)\n        },options=list(\n          paging = FALSE,\n          searching = FALSE))\n        \n\n        output$clust.brush_info <- renderDataTable({\n          \n          brushedPoints(tableData, input$clust.Plot_brush) \n        })\n        \n        \n        output$clustDownloadFilteredData <- downloadHandler(\n          filename = function() { \n            paste('filteredData', '.csv', sep='') \n          },\n          content = function(file) {\n            write.csv(brushedPoints(tableData, input$clust.Plot_brush), file,row.names = FALSE)\n          }\n        )\n        \n      }\n      \n    })  \n    \n    \n    ############################################################## Regression #####################################################################\n    #http://rpubs.com/sinhrks/plot_lm\n    #ggplot(lm.model, aes(.fitted, .resid))+geom_point() + stat_smooth(method=\"loess\")+geom_hline(yintercept=0, col=\"red\", linetype=\"dashed\") +xlab(\"Fitted values\")+ylab(\"Residuals\")+ggtitle(\"Residual vs Fitted Plot\")+theme_bw()\n    \n    \n    observe({\n      \n      options <- input$regression.in\n      if(!is.null(options)){\n        \n        try <- tryCatch({\n        \n        dataAll <- variablesEnv$currentData\n\n        if(options$logDependentVariable){\n          temdata <- log(dataAll[which(names(dataAll)==options$dependentVariable)])\n        }\n        else{\n          temdata <- dataAll[which(names(dataAll)==options$dependentVariable)]\n        }\n        \n        for ( i in 1:(length(names(dataAll))) ) {\n            if(length(which(names(dataAll)==options$variablesdName[i]))>0){\n              if((options$type == 'externals') && (options$variablesdNameLogTransf[i] == TRUE)) {\n                temdata[options$variablesdName[[i]]] <- log((dataAll[which(names(dataAll)==options$variablesdName[i])]))\n              }\n              else{\n                temdata[options$variablesdName[[i]]] <- (dataAll[which(names(dataAll)==options$variablesdName[i])])\n                \n              }\n            }\n        }\n\n        \n        variablesdName <- paste(options$variablesdName,collapse=\"+\")\n        total <- temdata[1]\n        total <- total[-c(1)]\n        \n        }, error = function(cond){\n          sendPopUpMessage(paste0('Error in data-input or transformation:  ',as.character(cond$message)))\n          return(NULL)})\n        \n        if(!is.null(try)){\n          try <- tryCatch({\n        \n        if(options$regressionMethod == 'lm'){\n          eval(parse(text = paste0('tmp <- lm(', options$dependentVariable,' ~ ',variablesdName,', data = unclass(temdata))')))\n          total <- merge(as.data.frame(tmp$fitted.values),as.data.frame(temdata[which(names(temdata)==options$dependentVariable)]), by=\"row.names\")\n          \n        }\n        \n        else if(options$regressionMethod == 'lmrob'){\n          eval(parse(text = paste0('tmp <- lmrob(', options$dependentVariable,' ~ ',variablesdName,', data = unclass(temdata))')))\n          total <- merge(as.data.frame(tmp$fitted.values),as.data.frame(temdata[which(names(temdata)==options$dependentVariable)]), by=\"row.names\")\n          \n        }\n        \n        else if(options$regressionMethod == 'lmCoDaX'){\n          if(options$lmCoDaX_RobustSelector == \"robust\"){\n            tmp <- lmCoDaX(temdata[,1], temdata[,-1], method = \"robust\")\n            #eval(parse(text = paste0('tmp <- lmCoDaX(unclass(temdata)[,1], unclass(temdata)[,-1], method = \"robust\")')))\n          }\n          else{\n            tmp <- lmCoDaX(temdata[,1], temdata[,-1], method = \"classical\")\n            #eval(parse(text = paste0('tmp <- lmCoDaX(unclass(temdata)[,1] , unclass(temdata)[,-1], method = \"classical\")')))\n          }\n          total <- merge(as.data.frame(tmp$lm$fitted.values),as.data.frame(temdata[which(names(temdata)==options$dependentVariable)]), by=\"row.names\")\n          \n        }\n        colnames(total)[2] <- \"fitted.values\"\n        colnames(total)[3] <- \"y\"\n        total <- transform(total, Row.names = as.numeric(Row.names))\n        \n          }, error = function(cond){\n            sendPopUpMessage(paste0('Error applying function ',options$regressionMethod ,':  ',as.character(cond$message)))\n            return(NULL)})\n        }\n        \n        if(!is.null(try)){\n          try <- tryCatch({\n        \n        output$regression.Plot <- renderPlot({\n          ggplot(data = total, aes(fitted.values ,y)) + geom_point() + geom_abline(intercept = 0, colour = \"red\")\n        })\n        \n        \n        #renderPrint\n        output$click_info <- renderDataTable({\n          round_df(nearPoints(total, input$regression.Plot_click),3)\n        },options=list(\n          paging = FALSE,\n          searching = FALSE))\n        \n        #renderPrint\n        output$brush_info <- renderDataTable({\n          \n          round_df(brushedPoints(total, input$regression.Plot_brush),3)\n        })\n        \n        output$render.tes <- renderPrint({\n          if(options$regressionMethod == 'lm' || options$regressionMethod == 'lmrob'){\n            print(summary(tmp))\n          }\n          else{\n            print(summary(tmp$lm))\n          }\n          \n        })\n        \n        \n        output$regression.diagnostic1 <- renderPlot({\n          if(options$regressionMethod == 'lm'){\n            plot(tmp, which = 1)          \n            }\n          else if(options$regressionMethod == 'lmrob'){\n            plot(tmp, which = 1)\n          }\n          else if(options$regressionMethod == 'lmCoDaX'){\n            if(options$lmCoDaX_RobustSelector == \"robust\"){\n              plot(tmp$lm, which = \"rqq\")\n            }\n            else{\n              plot(tmp$lm, which = 1)\n            }\n            \n          }\n        })\n        \n        output$regression.diagnostic2 <- renderPlot({\n          if(options$regressionMethod == 'lm'){\n            plot(tmp, which = 2)          \n          }\n          else if(options$regressionMethod == 'lmrob'){\n            plot(tmp, which = 2)\n          }\n          else if(options$regressionMethod == 'lmCoDaX'){\n            if(options$lmCoDaX_RobustSelector == \"robust\"){\n              plot(tmp$lm, which = \"rindex\")\n            }\n            else{\n              plot(tmp$lm, which = 2)\n            }\n          }\n        })\n        \n        output$regression.diagnostic3 <- renderPlot({\n          if(options$regressionMethod == 'lm'){\n            plot(tmp, which = 3)          \n          }\n          else if(options$regressionMethod == 'lmrob'){\n            plot(tmp, which = 3)\n          }\n          else if(options$regressionMethod == 'lmCoDaX'){\n            if(options$lmCoDaX_RobustSelector == \"robust\"){\n              plot(tmp$lm, which = \"rfit\")\n            }\n            else{\n              plot(tmp$lm, which = 3)\n            }\n          }\n        })\n        \n        output$regression.diagnostic4 <- renderPlot({\n          if(options$regressionMethod == 'lm'){\n            plot(tmp, which = 4)          \n          }\n          else if(options$regressionMethod == 'lmrob'){\n            plot(tmp, which = 4)\n          }\n          else if(options$regressionMethod == 'lmCoDaX'){\n            if(options$lmCoDaX_RobustSelector == \"robust\"){\n              plot(tmp$lm, which = \"rdiag\")\n            }\n            else{\n              plot(tmp$lm, which = 4)\n            }\n          }\n        })\n        \n        output$regression.diagnostic5 <- renderPlot({\n          if(options$regressionMethod == 'lmrob'){\n            plot(tmp, which = 5)\n          }\n        })\n        \n        \n        output$regressionDownloadResiduals <- downloadHandler(\n          filename = function() { \n            paste('residuals', '.csv', sep='') \n          },\n          content = function(file) {\n            if(options$regressionMethod == 'lm' || options$regressionMethod == 'lmrob'){\n              write.csv(as.data.frame(tmp$residuals), file,row.names = FALSE)\n            }\n            else{\n              write.csv(as.data.frame(tmp$lm$residuals), file,row.names = FALSE)\n            }\n            \n          }\n        )\n        \n        output$regressionDownloadFittedValues <- downloadHandler(\n          filename = function() { \n            paste('fitted values', '.csv', sep='') \n          },\n          content = function(file) {\n            if(options$regressionMethod == 'lm' || options$regressionMethod == 'lmrob'){\n              write.csv(as.data.frame(tmp$fitted.values), file,row.names = FALSE)\n            }\n            else{\n              write.csv(as.data.frame(tmp$lm$fitted.values), file,row.names = FALSE)\n            }\n            \n          }\n        )\n        \n          }, error = function(cond){\n            \n            sendPopUpMessage(paste0('Error while creating plots:  ',as.character(cond$message)))\n            return(NULL)})\n        }\n        \n      }\n      \n    })  \n    \n    \n    ############################################################## Outlier Detection #####################################################################\n    \n    #data(Animals, package =\"MASS\")\n    #brain <- Animals[c(1:24, 26:25, 27:28),]\n    \n    observe({\n      \n      options <- input$od.in\n      if(!is.null(options)){\n        try <- tryCatch({\n        \n          dataAll <- variablesEnv$currentData\n          temdata <- dataAll[1]\n          temdata <- temdata[-c(1)]\n          \n          for ( i in 1:(length(names(dataAll))) ) {\n            if(length(which(names(dataAll)==options$variablesdName[i]))>0){\n              if((options$type == 'externals') && (options$variablesdNameLogTransf[i] == TRUE)) {\n                temdata[options$variablesdName[[i]]] <- log((dataAll[which(names(dataAll)==options$variablesdName[i])]))\n              }\n              else{\n                temdata[options$variablesdName[[i]]] <- (dataAll[which(names(dataAll)==options$variablesdName[i])])\n                \n              }\n            }\n          }\n        }, error = function(cond){\n          sendPopUpMessage(paste0('Error in data-input or transformation:  ',as.character(cond$message)))\n          return(NULL)})\n        \n        \n            try <- tryCatch({\n                if(options$type == 'compositions'){\n                  tmp <- outCoDa(x =temdata , quantile = as.numeric(options$quantile), h = as.numeric(options$h), coda =TRUE )\n                  temdata <-isomlr(temdata)\n                  \n                  \n                }\n                else{\n                  tmp <- outCoDa(x =temdata , quantile = as.numeric(options$quantile), h = as.numeric(options$h), coda =FALSE )\n                }\n                md <- sqrt(mahalanobis(temdata, colMeans(temdata), var(temdata), tol = 1e-07))\n                rd <- sqrt(mahalanobis(temdata, covMcd(temdata)$center, covMcd(temdata)$cov, tol = 1e-07))\n                cutoff <- sqrt(qchisq(0.975, ncol(temdata)))\n                id.n <- length(which(rd > cutoff))\n            }, error = function(cond){\n            sendPopUpMessage(paste0('Error applying function:  ',as.character(cond$message)))\n            return(NULL)})\n        \n        \n        \n          try <- tryCatch({\n            output$od.summary <- renderPrint({\n                print(tmp)\n            })\n            \n            \n            output$od.DDPlot <- renderPlot({\n              xlab <- \"Mahalanobis distance\"\n              ylab <- \"Robust distance\"\n              plot(md, tmp$mahalDist, type = \"p\", xlab = xlab, ylab = ylab, main = \"Distance-Distance Plot\")\n              abline(0, 1, lty = 2)\n              abline(v = cutoff, h = cutoff)\n            })\n          }, error = function(cond){\n            \n            sendPopUpMessage(paste0('Error while creating plots:  ',as.character(cond$message)))\n            return(NULL)})\n        }\n      \n      \n    })  \n    \n\n#######################################################################################################################################\n################################################################ PLOT #################################################################\n#######################################################################################################################################\n############################################################## BAR-PLOT ###############################################################\n############################################################ VARIABLES ################################################################\n observe({\n    options <- input$variablesBarPlot\n    if(!is.null(options)){\n        data <- variablesEnv$currentData\n        variables <- c()\n        if(options$variablesType == 'transformations'){\n            data <- getVariables(options$variablesType, options$variablesName)\n        }else{\n            variables <- getVariables(options$variablesType, options$variablesName)\n        }\n\n        if(length(variables) > 0){\n            data <- data[, variables]\n        }\n\n        if(options$useSubset && length(options$currentSubset) > 0){\n            subset <- unlist(options$currentSubset) + 1\n            data <- data[subset,]\n        }\n        results <- list()\n        names <- names(data)\n        for(i in 1:length(data)){\n            try <- tryCatch({eval(parse(text = paste0('results[[names[i]]] <- ',options$method, '(data[,i])' )))},\n                            error = function(cond){return(NULL)})\n\n            if(is.null(try) || length(results[[names[i]]]) > 1){\n                sendPopUpMessage(paste0('ERROR: method \"', options$method, '\" is not supported' ))\n                resetConnector('variablesBarPlot')\n                return(NULL)\n            }\n        }\n        message = list()\n        message[['title']] <- options$title\n        message[['yAxis']] <- options$yAxis\n        message[['data']] <- results\n        session$sendCustomMessage(type ='plotBarPlot', message = message)\n        resetConnector('variablesBarPlot')\n    }\n })\n\n\n########################################################################################################################################\n############################################################## GROUP BAR PLOT ##########################################################\n########################################################################################################################################\nobserve({\n    options <- input$groupBarPlot\n    if(!is.null(options)){\n        data <- variablesEnv$currentData\n        factors <- unlist(data[options$factor])\n        uniqueFactors <- unique(factors)\n        variables <- c()\n\n        if(options$variablesType == 'transformations'){\n            data <- getVariables(options$variablesType, options$variablesName)\n        }else{\n            variables <- getVariables(options$variablesType, options$variablesName)\n        }\n\n        if(length(variables) > 0){\n            data <- data[, variables]\n        }\n\n        names <- names(data)\n        if(options$useSubset && length(options$currentSubset) > 0){\n            subset <- unlist(options$currentSubset) + 1\n            data <- data[subset,]\n        }\n\n        results <- list()\n        notToUseIndexes <- c()\n        for(i in 1:length(uniqueFactors)){\n            indexes <- which(factors == uniqueFactors[i])\n            tmpResult <- c()\n            verifInd <- 1\n            for(j in 1:length(names)){\n                if(is.numeric(unlist(data[names[j]]))){\n                    tmpData <- data[names[j]]\n\n                    tmpData <- tmpData[indexes, ]\n\n                    tmpData <- tmpData[complete.cases(tmpData)]\n\n                    try <- tryCatch({eval(parse(text = paste0('tmpResult <- c(tmpResult,', options$method, '(tmpData))')))},\n                            error = function(cond){return(NULL)})\n\n                    if(is.null(try) || (verifInd == 1 && length(tmpResult) > 1)){\n                        sendPopUpMessage(paste0('ERROR: method \"', options$method, '\" is not supported' ))\n                        resetConnector('groupBarPlot')\n                        return(NULL)\n                    }\n                    \n                    verifInd <- verifInd + 1\n                }else{\n                    notToUseIndexes <- c(notToUseIndexes, j)\n                }\n            }\n\n            results[[uniqueFactors[i]]] <- tmpResult\n        }\n\n        if(is.null(results) || length(results) == 0){\n            sendPopUpMessage('ERROR: chosen data can\\'t be ploted')\n            return(NULL)\n        }\n        results <- as.data.frame(results)\n        names(results) <- uniqueFactors\n        if(!is.null(notToUseIndexes)){\n            names <- names[-notToUseIndexes]\n        }\n        message <- list()\n        message[[\"data\"]] <- results\n        message[[\"names\"]] <- names\n        message[['title']] <- options$title\n        message[['yAxis']] <- options$yAxis\n\n        session$sendCustomMessage(type = 'plotGroupBarPlot', message = message)\n        resetConnector('groupBarPlot')\n    }\n\n})\n\n\n########################################################################################################################################\n################################################################ BOXPLOT ###############################################################\n########################################################################################################################################\n################################################################# FACTORS ##############################################################\n observe({\n    options <- input$boxPlotFactor\n    if(!is.null(options)){\n        data <- variablesEnv$currentData\n        factors <- unlist(data[options$factor])\n        uniqueFactors <- unique(factors)\n\n        try <- tryCatch({data <- data[options$variable]}, error = function(cond){return(NULL)})\n        if(is.null(try)){\n            data <- getVariableFromTransformation(options$variable)\n            if(is.null(data)){\n                sendPopUpMessage(paste0('ERROR: variable \"', options$variable,'\" doesn\\'t exist on this data-set!'))\n                return(NULL)\n            }\n        }\n        str(data)\n        dataLength <- length(data[,1])\n        if(options$method != \"\"){\n            try <- tryCatch({eval(parse(text = paste0('data <- ', options$method,'(data)')))},\n                        error = function(cond){return(NULL)})\n            str(data)\n            if(is.null(try) || length(data[,1]) != dataLength){\n                sendPopUpMessage(paste0('ERROR! function \"', options$method, '\" is not supported!'))\n                return(NULL)\n            }\n        }\n\n        if(options$useSubset && length(options$currentSubset) > 0){\n           subset <- unlist(options$currentSubset) + 1\n            data <- as.data.frame(data[subset,])\n        }\n\n        results <- list()\n        upperOutliers <- list()\n        lowerOutliers <- list()\n        for(i in 1:length(uniqueFactors)){\n            indexes <- which(factors == uniqueFactors[i])\n            tmpData <- data[indexes,]\n            tmpData <- tmpData[complete.cases(tmpData)]\n\n            try <- tryCatch({box <- boxplot(tmpData, plot=F)}, error = function(cond){return(NULL)})\n            if(is.null(try)){\n                sendPopUpMessage('ERROR: something went wrong!')\n                return(NULL)\n            }else{\n                results[[uniqueFactors[i]]] <- as.vector(box$stats)\n                upperOut <- as.vector(tmpData[tmpData > box$stats[5]])\n                if(length(upperOut) > 0){\n                    upperOutliers[[uniqueFactors[i]]] <- as.vector(upperOut)\n                }else\n                {\n                    upperOutliers[[uniqueFactors[i]]] <- as.list(\"no\")\n                }\n                lowerOut <- as.vector(tmpData[tmpData < box$stats[1]])\n                if(length(lowerOut) > 0){\n                    lowerOutliers[[uniqueFactors[i]]] <- as.vector(lowerOut)\n                }else{\n                    lowerOutliers[[uniqueFactors[i]]] <- as.list(\"no\")\n                }\n            }\n        }\n        names(results) <- uniqueFactors\n        names(upperOutliers) <- uniqueFactors\n        names(lowerOutliers) <- uniqueFactors\n\n        message <- list()\n        message[['results']] <- results\n        message[['upperOutliers']] <- upperOutliers\n        message[['lowerOutliers']] <- lowerOutliers\n        message[['categories']] <- uniqueFactors\n        message[['title']] <- options$title\n\n        session$sendCustomMessage(type = 'plotBoxPlot', message = message)\n        resetConnector('boxPlotFactor')\n    }\n })\n\n ############################################################### VARIABLES ###########################################################\n observe({\n    options <- input$boxPlotVariables\n    if(!is.null(options)){\n        data <- variablesEnv$currentData\n        variables <- c()\n\n        if(options$variablesType == 'transformations'){\n            data <- getVariables(options$variablesType, options$variablesName)\n        }else{\n            variables <- getVariables(options$variablesType, options$variablesName)\n        }\n\n        if(length(variables) > 0){\n            data <- data[, variables]\n         }\n\n        names <- names(data)\n        if(options$useSubset && length(options$currentSubset) > 0){\n            subset <- unlist(options$currentSubset) + 1\n            data <- data[subset,]\n        }\n\n        results <- list()\n        upperOutliers <- list()\n        lowerOutliers <- list()\n        for(i in 1:length(names)){\n            tmpData <- data[names[i]]\n\n            try <- tryCatch({box <- boxplot(tmpData, plot=F)}, error = function(cond){return(NULL)})\n            if(is.null(try)){\n                sendPopUpMessage('ERROR: something went wrong!')\n                return(NULL)\n            }else{\n                results[[names[i]]] <- as.vector(box$stats)\n                upperOut <- as.vector(tmpData[tmpData > box$stats[5]])\n                if(length(upperOut) > 0){\n                    upperOutliers[[names[i]]] <- upperOut\n                }else\n                {\n                    upperOutliers[[names[i]]] <- as.list(\"no\")\n                }\n                lowerOut <- as.vector(tmpData[tmpData < box$stats[1]])\n                if(length(lowerOut) > 0){\n                    lowerOutliers[[names[i]]] <- lowerOut\n                }else{\n                    lowerOutliers[[names[i]]] <- as.list(\"no\")\n                }\n            }\n        }\n        names(results) <- names\n        names(upperOutliers) <- names\n        names(lowerOutliers) <- names\n\n        message <- list()\n        message[['results']] <- results\n        message[['upperOutliers']] <- upperOutliers\n        message[['lowerOutliers']] <- lowerOutliers\n        message[['categories']] <- names\n        message[['title']] <- options$title\n\n        session$sendCustomMessage(type = 'plotBoxPlot', message = message)\n        resetConnector('boxPlotVariables')\n    }\n })\n\n\n\n})\n\n",
    "created" : 1447337857735.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4067719056",
    "id" : "82939277",
    "lastKnownWriteTime" : 1447969759,
    "path" : "C:/Users/Jakob/shiny/r-shiny_v1.1/shiny/server.R",
    "project_path" : "shiny/server.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}